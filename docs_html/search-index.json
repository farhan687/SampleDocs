[{"content":"<h1 id=\"how-to\">How to</h1>","link":"./scalr/FAQs/rest.html","spaLink":"#/scalr/FAQs/rest","title":"HOW TO"},{"content":"<h2 id=\"how-to-update-mapping-without-losing-data\">Update mapping without losing data</h2><p>Although you can add new types to an index, or add new fields to a type, you can’t add new analyzers or make changes to existing fields. If you were to do so, the data that had already been indexed would be incorrect and your searches would no longer work as expected. Here’s a short gist on how mappings work:</p><p>In order to make your data searchable, your database needs to know what type of data each field contains and how it should be indexed. If you switch a field type from e.g. a string to a date, all of the data for that field that you already have indexed cannot be used because of the datatype mismatch. In such situations, you need to reindex that field.</p><p>This applies not just to Appbase (or Elasticsearch / Lucene - the datastore used by Appbase), but to any database that uses indices for searching. And if it isn’t using indices then it is sacrificing speed for flexibility.</p><p>There is one situation where re-indexing is not required: when adding a field, as a previous mapping for the field didn’t exist and Appbase can infer the field datatype when it’s indexed for the first time.</p><p>Since updating mapping =&gt; reindexing data, let’s take a look at that.</p>","link":"./scalr/FAQs/rest.html","spaLink":"#/scalr/FAQs/rest","title":"UPDATE MAPPING WITHOUT LOSING DATA"},{"content":"<h3 id=\"how-to-update-mapping-without-losing-data-reindexing-your-data\">Reindexing your data</h3><p>The process for reindexing your data is quite simple. First, create a new app in appbase and update the new mapping and settings:  </p><p>One of the advantages of the _source field is that you already have the whole document available to you in Elasticsearch itself. You don’t have to rebuild your index from the database, which is usually much slower.</p><p>To reindex all of the documents from the old index efficiently, use <a href=\"https://www.elastic.co/guide/en/elasticsearch/guide/current/scan-scroll.html\">scan-and-scroll</a> to retrieve batches of documents from the old index, and the <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-writing-data-bulk\">bulk API</a> to push them into the new index.</p>","link":"./scalr/FAQs/rest.html","spaLink":"#/scalr/FAQs/rest","title":"Reindexing your data"},{"content":"<h3 id=\"how-to-update-mapping-without-losing-data-reindexing-in-batches\">Reindexing in Batches</h3><p>You can run multiple reindexing jobs at the same time, but you obviously don’t want their results to overlap. Instead, break a big reindex down into smaller jobs by filtering on a date or timestamp field:  </p><p>If you continue making changes to the old app, you will want to make sure that you include the newly added documents in your new app as well. This can be done by rerunning the reindex process, but again filtering on a date field to match only documents that have been added since the last reindex process started.</p><p>Reference: <a href=\"https://www.elastic.co/blog/changing-mapping-with-zero-downtime\">Elastic Search blog</a></p>","link":"./scalr/FAQs/rest.html","spaLink":"#/scalr/FAQs/rest","title":"Reindexing in Batches"},{"content":"<h1 id=\"how-to\">How to</h1>","link":"./scalr/FAQs/jsapi.html","spaLink":"#/scalr/FAQs/jsapi","title":"HOW TO"},{"content":"<h2 id=\"how-to-unsubscribe-from-a-streaming-query\">Unsubscribe from a streaming query</h2><p>The JS API methods for the <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-setup-new-appbase\"><code>appbaseRef</code></a> object implement a <strong>streams</strong> interface. Let’s see an example:</p><p>Unsubscribing from the <code>responseStream</code> is simple: using <code>stop()</code> method.</p><p><span class=\"fa fa-info-circle\"></span> The same is true for all other methods (like <code>index()</code>, <code>getStream()</code>) as well, data is returned asynchronously via the ‘data’ event handler.</p>","link":"./scalr/FAQs/jsapi.html","spaLink":"#/scalr/FAQs/jsapi","title":"UNSUBSCRIBE FROM A STREAMING QUERY"},{"content":"<h2 id=\"how-to-pause-a-streaming-query\">Pause a streaming query</h2><p><a href=\"https://nodejs.org/api/stream.html#stream_readable_pause\">Pausing a response stream object</a> prevents new data responses from emitting. The stream can be resumed again via conveniently named <code>responseStream.resume()</code>.</p><p><span class=\"fa fa-info-circle\"></span> <strong>pause()</strong> vs <strong>stop()</strong> - pause() merely prevents emitting new responses in the ‘data’ event handler, all the response stream object buffers the new events emitted by the <code>searchStream()</code> method. When resume() is called, all these responses are returned by the ‘data’ event handler. </p><p>By contrast, <code>stop()</code> unsubscribes from the query and kills the response stream object.</p><p><span class=\"fa fa-star\"></span> Check out more things you can do with streams here -  <a href=\"http://www.sitepoint.com/basics-node-js-streams/\">http://www.sitepoint.com/basics-node-js-streams/</a>.</p>","link":"./scalr/FAQs/jsapi.html","spaLink":"#/scalr/FAQs/jsapi","title":"PAUSE A STREAMING QUERY"},{"content":"<h2 id=\"how-to-stream-results-of-a-range-query\">Stream results of a range query</h2><p>Appbase.io implements a streaming interface for the entire <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/1.7/query-dsl.html\">Query DSL</a> supported by ElasticSearch. So if we can compose a range query, making it return continuous results is easy.</p><p>Let’s say we have a <strong>type</strong> called <em>items</em> which contains items with their corresponding value. An example document inside the <em>items</em> type looks like:</p><p>Composing the query:</p><p>The default state of <code>responseStream</code> object is paused. As soon as attach a data handler to it, it will start streaming the responses.</p>","link":"./scalr/FAQs/jsapi.html","spaLink":"#/scalr/FAQs/jsapi","title":"STREAM RESULTS OF A RANGE QUERY"},{"content":"<h2 id=\"how-to-change-the-default-results-in-a-search-query\">Change the default results in a search query</h2><p>Appbase returns 10 objects in the initial response to <code>searchStream()</code> method. Sometimes, we need to return more objects. We can do this by specifying the <code>size</code> attribute inside our query like this:</p><p>The <code>responseStream</code> object will now return max(total_objects_matching_our_query, 100) objects on the <code>'data'</code> event handler.</p><p><span class=\"fa fa-star\"></span> The <code>size</code> attribute can specify a maximum of 1000 objects to return in one response.</p><p><span class=\"fa fa-info-circle\"></span> <code>size</code> attribute can be applied on both <code>searchStream()</code> and <code>search()</code> methods.</p>","link":"./scalr/FAQs/jsapi.html","spaLink":"#/scalr/FAQs/jsapi","title":"CHANGE THE DEFAULT RESULTS IN A SEARCH QUERY"},{"content":"<h1 id=\"appbase-data-model\">Appbase Data Model</h1>","link":"./scalr/concepts/datamodel.html","spaLink":"#/scalr/concepts/datamodel","title":"APPBASE DATA MODEL"},{"content":"<h2 id=\"appbase-data-model-what-is-appbaseio\">What is appbase.io</h2><p><a href=\"https://appbase.io\">Appbase.io</a> is a data streams API service for continuous search and aggregation queries. You can build reactive apps with Appbase.io, where views update in conjunction with the data changes.</p><p>It enables you to:  </p><ul>\n<li>Build a blazing fast text search, messaging systems, or implement a mix of esoteric filters (fuzzy, geo, terms, range, multiple items),</li>\n<li>Stream JSON results directly as new data is added or the original data is updated,  </li>\n<li>Scale seamlessly upto 10,000 updates per second and store at terbyte scale.</li>\n</ul><p><img src=\"http://i.imgur.com/iJpqtks.png?1\" alt=\"Appbase Architecture\"><br><strong>Image 1:</strong> It provides a reliable data streams API as a service, while leveraging ElasticSearch (and Lucene) for storage and search.</p><p>While not primarily intended, Appbase.io can also be used as a hosted ElasticSearch API or as a message queue with a publish / subscribe model.</p><p>There are some catches if you intend to:  </p><ul>\n<li>Use it as a primary data store - ElasticSearch is <a href=\"https://www.elastic.co/guide/en/elasticsearch/resiliency/current/index.html#_loss_of_documents_during_network_partition_status_ongoing\">known to lose data</a> for some time on network partitions.<br><code>Status:</code> We are working towards adding support for durability by using Apache Kafka as a frontend (things you can do in SaaS!).</li>\n<li>Model financial or sensitive data - Appbase.io is not ACIDic and we don’t intend to be. A good design choice in this situation would be to use something that supports ACID transactions for storing sensitive data, and use Appbase.io for the data that needs to be searchable or accessed in realtime.</li>\n<li>Use it for OLAP use-cases - Appbase.io is designed as an OLTP system although it supports aggregations and queries on data sets of the size of terabytes. There are plenty of ideal tools for OLAP use-cases - Amazon Redshift, Google Big Query, Apache Hadoop and Appbase.io can be used with any of them (via REST API).</li>\n</ul>","link":"./scalr/concepts/datamodel.html","spaLink":"#/scalr/concepts/datamodel","title":"WHAT IS APPBASE.IO"},{"content":"<h1 id=\"appbase-data-schema\">Appbase Data Schema</h1><p>Appbase uses the same data schema as ElasticSearch.</p>","link":"./scalr/concepts/datamodel.html","spaLink":"#/scalr/concepts/datamodel","title":"APPBASE DATA SCHEMA"},{"content":"<h2 id=\"appbase-data-schema-app-aka-index\">App <span style=\"font-weight: 200;\">aka Index</span></h2><p>An app in <a href=\"https://appbase.io\">appbase.io</a> is stored as an index in ElasticSearch. App is the highest level of construct supported by appbase and is equivalent to a <strong>database</strong> in SQL.</p>","link":"./scalr/concepts/datamodel.html","spaLink":"#/scalr/concepts/datamodel","title":"APP AKA INDEX"},{"content":"<h2 id=\"appbase-data-schema-type\">Type</h2><p>Types are equivalent to <strong>tables</strong> in SQL. Data in an app is always stored within it’s types. A good way to think of them is as collections of different kinds of data.</p>","link":"./scalr/concepts/datamodel.html","spaLink":"#/scalr/concepts/datamodel","title":"TYPE"},{"content":"<h2 id=\"appbase-data-schema-document\">Document</h2><p>A <strong>document</strong> is the actual data stored in Appbase. Documents are <code>JSON</code> objects, equivalent to <strong>records</strong> or <strong>rows</strong> in SQL.</p><p><br></p>","link":"./scalr/concepts/datamodel.html","spaLink":"#/scalr/concepts/datamodel","title":"DOCUMENT"},{"content":"<h2 id=\"appbase-data-schema-visualizing-the-data-model\">Visualizing the Data Model</h2><p>An app can have one or more types and each type is a container for JSON documents. Visually, the arrangement looks like below:</p><p><img src=\"https://farm1.staticflickr.com/616/21319701888_dbe75d9f6f_c.jpg\" alt=\"img\"></p>","link":"./scalr/concepts/datamodel.html","spaLink":"#/scalr/concepts/datamodel","title":"VISUALIZING THE DATA MODEL"},{"content":"<h1 id=\"api-prime-objective-scale\"><img src=\"http://i.imgur.com/Eppz2lz.png?1\" alt=\"SCALR\"> API Prime Objective: Scale</h1><p>As the name suggests, our prime focus with this iteration of the API has been achieving a massive scale of API operations, to the tune of <a href=\"http://news.appbase.io/scaling-elasticsearch-writes/\">100,000 writes</a> and reads (yet to corroborate) per second. </p><p>You might wonder - why is addressing scale so important? A typical successful application would never exceed a throughput of a  few hundred requests per second and generally be okay with serving responses in time.</p><p>So much complexity in software comes from trying to make one thing do two things.<br>-Ryan Singer</p><p>This quote from Ryan Singer especially sings true when one thinks of scaling database operations. So much of the software service complexities stem from keeping up with the infrastructure needs, that those end up turning into burning pain points. It should come as no surprise that most mainstream distributed systems were born out of the scaling pain points faced by the 0.01% of applications.</p><p>Not only does addressing scale solve the burning pain points faced by the 0.01%, it provides confidence around the edge-cases and leads to faster adoption in production environments and success stories. We hope all of these come true for SCALR. In building SCALR, focusing on scale has lead us to a better foundational design, a more rigorously tested codebase, and a fine-grained monitoring of our deployment infrastructure. We’ll go more in depth about these learnings over the next few months, but most importantly - for the 99.9% folks reading this, <code>SCALR</code> has tons of improvements and features over <code>v2</code>.</p>","link":"./scalr/concepts/intro.html","spaLink":"#/scalr/concepts/intro","title":" API PRIME OBJECTIVE: SCALE"},{"content":"<h1 id=\"git-diff-changes-human\">git diff changes - -  human</h1><p>Welcome to the land of SCALR, where everyone smiles and the sun shines bright. </p><p><img src=\"http://i.imgur.com/3nYaIQM.png?1\" alt=\"SCALR banner image\"></p><p>Our beloved Hobo Lobo is chalking a ‘SCALR’ 101. </p><p>“changes what?”, asks someone.<br>“Everything”, says Hobo Lobo rather curtly.</p>","link":"./scalr/concepts/intro.html","spaLink":"#/scalr/concepts/intro","title":"GIT DIFF CHANGES - - HUMAN"},{"content":"<h2 id=\"git-diff-changes-human-scalr-whats-in-a-name\"><code>SCALR</code> - What’s in a name</h2><p>The most tangible change is in the codename - <code>scalr</code>. Breaking the convention of keeping a dull version name like <code>v2.0</code>, we will go with the version <code>scalr</code>. Docs for scalr are available at <a href=\"\">http://docs.appbase.io/</a> and the API base URL would be <code>https://scalr.api.appbase.io</code>.</p>","link":"./scalr/concepts/intro.html","spaLink":"#/scalr/concepts/intro","title":"SCALR - WHAT’S IN A NAME"},{"content":"<h2 id=\"git-diff-changes-human-compatibility-with-elasticsearch\">Compatibility with ElasticSearch</h2><p><code>scalr</code> is compatible out of the box with the ElasticSearch APIs. This means our users can take advantage of the vast plethora of client libraries made available by the folks at Elastic, have access to a vibrant open-source community and have the freedom to import / export data from Appbase.io conveniently. </p>","link":"./scalr/concepts/intro.html","spaLink":"#/scalr/concepts/intro","title":"COMPATIBILITY WITH ELASTICSEARCH"},{"content":"<h3 id=\"git-diff-changes-human-compatibility-with-elasticsearch-http-basic-authentication\">HTTP Basic Authentication</h3><p><code>scalr</code> uses HTTP Basic Authentication for securing app access (similar to Github and Wordpress’s authentication mechanisms). Every Appbase app can have one or more access tokens (username, password) with differing read and write permissions to allow fine-grained access. ElasticSearch’s access tokens work in the same way, a major compatibility win.</p><p>Note: This is a change from the earlier use of authentication header called <code>Appbase-Secret</code>.</p>","link":"./scalr/concepts/intro.html","spaLink":"#/scalr/concepts/intro","title":"HTTP Basic Authentication"},{"content":"<h3 id=\"git-diff-changes-human-compatibility-with-elasticsearch-whats-not-compatible\">What’s not compatible?</h3><p>The APIs related to devops, like clusters, multi-index operations, index creation are not a part of Appbase.io. Appbase is opinionated about devops.</p>","link":"./scalr/concepts/intro.html","spaLink":"#/scalr/concepts/intro","title":"What’s not compatible?"},{"content":"<h2 id=\"git-diff-changes-human-data-streams-20\">Data Streams 2.0</h2><p>Data Streams aka realtime events are rethought in <code>SCALR</code>. Instead of being a websockets based extension of the API to track just the document and reference changes, data streams are deeply baked into the <code>SCALR</code> API. Data Streams are implemented over both <strong>websockets</strong> (for browsers) and <strong>http-streaming</strong> (for other runtimes) and are pervasive over web, mobile and language native libraries. Data Streams can stream results of queries and filters as new data comes into the system.</p>","link":"./scalr/concepts/intro.html","spaLink":"#/scalr/concepts/intro","title":"DATA STREAMS 2.0"},{"content":"<h2 id=\"git-diff-changes-human-adieu-to-graph-datamodel\">Adieu to Graph datamodel</h2><p><code>SCALR</code> the JSON based schema-free datamodel of ElasticSearch. This is a major change over the graph datamodel extensively used by the <code>v2</code> API. The move is aimed at simplicity and to provide a less opinionated data model. True graph relationships can still be modeled in <code>SCALR</code>.</p>","link":"./scalr/concepts/intro.html","spaLink":"#/scalr/concepts/intro","title":"ADIEU TO GRAPH DATAMODEL"},{"content":"<h1 id=\"golang-api-reference\">GOLANG API REFERENCE</h1><p><a href=\"https://github.com/appbaseio/go-appbase\">go-appbase</a> is a data streams library for Go.</p><p>It can:</p><ul>\n<li>Continuously stream updates to documents, queries or filters over http-streams.  </li>\n<li>Index new documents and update existing ones.  </li>\n<li>Is compatible with <a href=\"https://github.com/olivere/elastic\">Elasticsearch’s Go Client</a> maintained by Olivere. </li>\n</ul><p>You can read the quick start guide for installation and basic usage. You can also read the API doc from godoc directly <a href=\"https://godoc.org/github.com/appbaseio/go-appbase\">here</a>.</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"GOLANG API REFERENCE"},{"content":"<h2 id=\"golang-api-reference-setup\">SETUP</h2>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"SETUP"},{"content":"<h3 id=\"golang-api-reference-setup-newclient\">NewClient</h3><p><strong>Usage</strong></p><p><code>func NewClient(URL string, username string, password string, appname string) (*Client, error)</code>  </p><ul>\n<li><strong>URL</strong> <code>string</code>- URL with the API version, always <em><a href=\"https://scalr.api.appbase.io\">https://scalr.api.appbase.io</a></em> </li>\n<li><strong>username</strong> <code>string</code> - username for the app as displayed in the dashboard</li>\n<li><strong>password</strong> <code>string</code> - password for the app as displayed in the dashboard</li>\n<li><strong>appname</strong> <code>string</code> - name of the app as displayed in the <a href=\"https://appbase.io/scalr\">dashboard</a></li>\n</ul><p><strong>Returns</strong></p><p>Returns a <strong>Client</strong> struct which has - <code>Ping()</code>, <code>Index()</code>, <code>Get()</code>, <code>GetStream()</code>, <code>Update()</code>, <code>Delete()</code>, <code>Search()</code>, <code>SearchStream()</code>, and <code>SearchStreamToURL()</code>.</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"NewClient"},{"content":"<h3 id=\"golang-api-reference-setup-delete\">Delete</h3><p>Delete returns a DeleteService which is used to delete a document</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"Delete"},{"content":"<h3 id=\"golang-api-reference-setup-get\">Get</h3><p>Get returns a GetService which is used to retrieve a document</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"Get"},{"content":"<h3 id=\"golang-api-reference-setup-getstream\">GetStream</h3><p>GetStream is used to start a stream of updates corresponding to a document</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"GetStream"},{"content":"<h3 id=\"golang-api-reference-setup-index\">Index</h3><p>Index returns an IndexService which is used to index a document</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"Index"},{"content":"<h3 id=\"golang-api-reference-setup-ping\">Ping</h3>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"Ping"},{"content":"<h3 id=\"golang-api-reference-setup-search\">Search</h3><p>Search provides access to Elasticsearch’s search functionality</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"Search"},{"content":"<h3 id=\"golang-api-reference-setup-searchstream\">SearchStream</h3><p>SearchStream is used to get updates corresponding to a query</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"SearchStream"},{"content":"<h3 id=\"golang-api-reference-setup-searchstreamtourl\">SearchStreamToURL</h3><p>SearchStream is used to send updates corresponding to a query to an URL</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"SearchStreamToURL"},{"content":"<h3 id=\"golang-api-reference-setup-update\">Update</h3><p>Update returns an UpdateService which is used to update a document</p>","link":"./scalr/golang/api-reference.html","spaLink":"#/scalr/golang/api-reference","title":"Update"},{"content":"<h1 id=\"javascript-api-reference\">Javascript API Reference</h1><p>Appbase.JS is a minimalistic library for data streams.</p><p>It can:</p><ul>\n<li>Continuously stream updates to documents, queries or filters over websockets (for browsers) and http-streams.</li>\n<li>Index new documents or update / delete existing ones.</li>\n<li>Is compatible with <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html\">elasticsearch.js</a>, which can be used for modifying the ES configurations and for using more esoteric methods.</li>\n</ul><p>You can read the <a href=\"http://docs.appbase.io/scalr/javascript/javascript-intro.html\">Javascript</a> or <a href=\"http://docs.appbase.io/scalr/javascript/nodejs-intro.html\">Node.JS</a> quick-start guides for installation and basic usage.</p>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"JAVASCRIPT API REFERENCE"},{"content":"<h2 id=\"javascript-api-reference-setup\">SETUP</h2>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"SETUP"},{"content":"<h3 id=\"javascript-api-reference-setup-new-appbase\">new Appbase()</h3><p>Returns a new Appbase object (refered to as <code>appbaseRef</code> in all the following examples) using the <code>url</code>, <code>appname</code> and <code>username</code>:<code>password</code> credentials.</p><p><strong>Usage</strong></p><p><code>new Appbase(appData)</code></p><ul>\n<li><p><strong>appData</strong> <code>Object</code> - A Javascript object containing the following fields and values</p>\n<ul>\n<li><strong>url</strong> <code>String</code> - URL with the API version, always <em><a href=\"https://scalr.api.appbase.io\">https://scalr.api.appbase.io</a></em></li>\n<li><strong>appname</strong> <code>String</code> - name of the app as displayed in the <a href=\"https://appbase.io/scalr\">dashboard</a></li>\n<li><strong>username</strong> <code>String</code> - username as displayed in the app dashboard</li>\n<li><strong>password</strong> <code>String</code> - password as displayed in the app dashboard</li>\n</ul>\n</li>\n</ul><p><strong>appData</strong> <code>Object</code> - A Javascript object containing the following fields and values</p><ul>\n<li><strong>url</strong> <code>String</code> - URL with the API version, always <em><a href=\"https://scalr.api.appbase.io\">https://scalr.api.appbase.io</a></em></li>\n<li><strong>appname</strong> <code>String</code> - name of the app as displayed in the <a href=\"https://appbase.io/scalr\">dashboard</a></li>\n<li><strong>username</strong> <code>String</code> - username as displayed in the app dashboard</li>\n<li><strong>password</strong> <code>String</code> - password as displayed in the app dashboard</li>\n</ul><p><strong>Returns</strong></p><p><code>Object</code> <strong>appbaseRef</strong> <em>Appbase reference object</em> - has <code>index()</code>, <code>update()</code>, <code>delete()</code>, <code>bulk()</code>, <code>search()</code>, <code>get()</code>, <code>getTypes()</code>, <code>getStream()</code>, <code>searchStream()</code> and <code>searchStreamToURL()</code> methods.</p>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"new Appbase()"},{"content":"<h2 id=\"javascript-api-reference-writing-data\">WRITING DATA</h2>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"WRITING DATA"},{"content":"<h3 id=\"javascript-api-reference-writing-data-index\">index()</h3><p>Writes a JSON data object at a given <code>type</code> and <code>id</code> location, or replaces if an object already exists.</p><p><strong>Usage</strong></p><p><code>appbaseRef.index(params)</code></p><ul>\n<li><p><strong>params</strong> <code>Object</code> - A Javascript object containing the type, id and the JSON data to be indexed</p>\n<ul>\n<li><strong>type</strong> <code>String</code> - The type (aka collection) under which the data will be indexed</li>\n<li><strong>body</strong> <code>Object</code> - Data to be indexed, a valid JSON object</li>\n<li><strong>id</strong> <code>String</code> - Unique ID for the JSON data. <code>id</code> is auto generated if not specified</li>\n</ul>\n</li>\n</ul><p><strong>params</strong> <code>Object</code> - A Javascript object containing the type, id and the JSON data to be indexed</p><ul>\n<li><strong>type</strong> <code>String</code> - The type (aka collection) under which the data will be indexed</li>\n<li><strong>body</strong> <code>Object</code> - Data to be indexed, a valid JSON object</li>\n<li><strong>id</strong> <code>String</code> - Unique ID for the JSON data. <code>id</code> is auto generated if not specified</li>\n</ul>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"index()"},{"content":"<h3 id=\"javascript-api-reference-writing-data-update\">update()</h3><p>Partially updates an existing document at a given <code>type</code> and <code>id</code> location. The important difference with the index() method is that the latter replaces the existing data values wholesale, while update() only replaces the values that are specified in the <code>body.doc</code> field.</p><p><strong>Usage</strong></p><p><code>appbaseRef.update(params)</code></p><ul>\n<li><p><strong>params</strong> <code>Object</code> - A Javascript object containing the type, id, and the partial JSON data to be updated</p>\n<ul>\n<li><strong>type</strong> <code>String</code> - The type (aka collection) under which the data will be indexed</li>\n<li><strong>body.doc</strong> <code>Object</code> - Partial doc JSON to be updated (all the JSON data can only reside under the body.doc field)</li>\n<li><strong>id</strong> <code>String</code> - Unique ID of the JSON document to be updated. <code>id</code> here is mandatory and should match an existing object.</li>\n</ul>\n</li>\n</ul><p><strong>params</strong> <code>Object</code> - A Javascript object containing the type, id, and the partial JSON data to be updated</p><ul>\n<li><strong>type</strong> <code>String</code> - The type (aka collection) under which the data will be indexed</li>\n<li><strong>body.doc</strong> <code>Object</code> - Partial doc JSON to be updated (all the JSON data can only reside under the body.doc field)</li>\n<li><strong>id</strong> <code>String</code> - Unique ID of the JSON document to be updated. <code>id</code> here is mandatory and should match an existing object.</li>\n</ul>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"update()"},{"content":"<h3 id=\"javascript-api-reference-writing-data-delete\">delete()</h3><p>Delete a JSON data object by <code>id</code>.</p><p><strong>Usage</strong></p><p><code>appbaseRef.delete(params)</code></p><ul>\n<li><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>type</code> and <code>id</code> of the JSON object to be deleted</p>\n<ul>\n<li><strong>type</strong> <code>String</code> - The type (aka collection) of the object to be deleted</li>\n<li><strong>id</strong> <code>String</code> - Unique ID for the JSON data</li>\n</ul>\n</li>\n</ul><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>type</code> and <code>id</code> of the JSON object to be deleted</p><ul>\n<li><strong>type</strong> <code>String</code> - The type (aka collection) of the object to be deleted</li>\n<li><strong>id</strong> <code>String</code> - Unique ID for the JSON data</li>\n</ul>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"delete()"},{"content":"<h3 id=\"javascript-api-reference-writing-data-bulk\">bulk()</h3><p>Apply many index / delete operations together, useful when importing data for the first time.</p><p><strong>Usage</strong></p><p><code>appbaseRef.bulk(params)</code></p><ul>\n<li><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>body</code> and optionally a default <code>type</code> to be used for actions</p>\n<ul>\n<li><strong>body</strong> <code>String</code> - A Javascript array of actions to be performed written as a sequence of action#1, data#1, action#2, data#2, … action#n, data#n</li>\n<li><strong>type</strong> <code>String</code> - Default document type for actions that don’t provide one</li>\n</ul>\n</li>\n</ul><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>body</code> and optionally a default <code>type</code> to be used for actions</p><ul>\n<li><strong>body</strong> <code>String</code> - A Javascript array of actions to be performed written as a sequence of action#1, data#1, action#2, data#2, … action#n, data#n</li>\n<li><strong>type</strong> <code>String</code> - Default document type for actions that don’t provide one</li>\n</ul>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"bulk()"},{"content":"<h2 id=\"javascript-api-reference-getting-data\">GETTING DATA</h2>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"GETTING DATA"},{"content":"<h3 id=\"javascript-api-reference-getting-data-get\">get()</h3><p>Get the JSON document from a particular <code>type</code> and <code>id</code>. For subscribing to realtime updates on a document, check out <code>getStream()</code>.</p><p><strong>Usage</strong></p><p><code>appbaseRef.get(params)</code></p><ul>\n<li><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>type</code> and <code>id</code> of the document to retrieve.  <ul>\n<li><strong>type</strong> <code>String</code> - Document Type</li>\n<li><strong>id</strong> <code>String</code> - Unique ID of the JSON document</li>\n</ul>\n</li>\n</ul><ul>\n<li><strong>type</strong> <code>String</code> - Document Type</li>\n<li><strong>id</strong> <code>String</code> - Unique ID of the JSON document</li>\n</ul><p>Returns the document at the given <code>type</code> and <code>id</code>.</p>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"get()"},{"content":"<h3 id=\"javascript-api-reference-getting-data-gettypes\">getTypes()</h3><p>Get all the <code>types</code> of an appname.</p><p><strong>Usage</strong></p><p><code>appbaseRef.getTypes()</code></p><p>Returns all the <code>types</code> as an array.</p>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"getTypes()"},{"content":"<h3 id=\"javascript-api-reference-getting-data-search\">search()</h3><p>Search for matching documents in a type. It’s a convenience method for ElasticSearch’s <code>/_search</code> endpoint.  For subscribing to realtime updates on the search query, check out <code>searchStream()</code>.</p><p><strong>Usage</strong></p><p><code>appbaseRef.search(params)</code></p><ul>\n<li><p><strong>params</strong> <code>Object</code> - A Javascript object containing the query <code>type</code> and <code>body</code>.</p>\n<ul>\n<li><strong>type</strong> <code>String</code> - Document type</li>\n<li><strong>body</strong> <code>String</code> - A JSON object specifying a valid query in the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\">ElasticSearch Query DSL</a> format</li>\n</ul>\n</li>\n</ul><p><strong>params</strong> <code>Object</code> - A Javascript object containing the query <code>type</code> and <code>body</code>.</p><ul>\n<li><strong>type</strong> <code>String</code> - Document type</li>\n<li><strong>body</strong> <code>String</code> - A JSON object specifying a valid query in the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\">ElasticSearch Query DSL</a> format</li>\n</ul><p><strong>Returns</strong></p><p><a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream.Readable</a> <code>Object</code> with</p><ul>\n<li><code>'data'</code> and <code>'error'</code> event handlers to return the results and any errors.</li>\n</ul>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"search()"},{"content":"<h2 id=\"javascript-api-reference-streaming-data\">STREAMING DATA</h2>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"STREAMING DATA"},{"content":"<h3 id=\"javascript-api-reference-streaming-data-getstream\">getStream()</h3><p>Continuously stream new updates to a specific JSON document. If you wish to only fetch the existing value, <code>get()</code> is sufficient.</p><p><strong>Usage</strong></p><p><code>appbaseRef.getStream(params)</code></p><ul>\n<li><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>type</code> and <code>id</code> of the document to be streamed.</p>\n<ul>\n<li><strong>type</strong> <code>String</code> - Document type</li>\n<li><strong>id</strong> <code>String</code> - Document ID (The ID is always a <code>String</code> value)</li>\n</ul>\n</li>\n</ul><p><strong>params</strong> <code>Object</code> - A Javascript object containing the <code>type</code> and <code>id</code> of the document to be streamed.</p><ul>\n<li><strong>type</strong> <code>String</code> - Document type</li>\n<li><strong>id</strong> <code>String</code> - Document ID (The ID is always a <code>String</code> value)</li>\n</ul><p><span class=\"fa fa-info-circle\"></span> The <code>streamOnly</code> field parameter is deprecated starting v0.9.0 onwards, and is the default for how <code>getStream()</code> works (previously <code>readStream()</code>).</p><p><strong>Returns</strong></p><p><a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream.Readable</a> <code>Object</code> with</p><ul>\n<li><code>'data'</code> and <code>'error'</code> event handlers</li>\n<li>a <strong>stop()</strong> method to stop the stream</li>\n</ul><p><code>Note:</code> appbase.js lib uses websockets to stream the updates.</p>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"getStream()"},{"content":"<h3 id=\"javascript-api-reference-streaming-data-searchstream\">searchStream()</h3><p>Continuously stream results of search query on a given <code>type</code>. Search queries can be a variety of things: from simple monitoring queries, finding an exact set of documents, full-text search queries, to geolocation queries.</p><p><code>searchStream()</code> subscribes to search results on new document inserts, existing search results can be fetched via <code>search()</code> method.</p><p><strong>Usage</strong></p><p><code>appbaseRef.searchStream(params)</code></p><ul>\n<li><p><strong>params</strong> <code>Object</code> - A Javascript object containing the query <code>type</code> and <code>body</code></p>\n<ul>\n<li><strong>type</strong> <code>String</code> - Document type</li>\n<li><strong>body</strong> <code>String</code> - A JSON object specifying a valid query in the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\">ElasticSearch Query DSL</a> format</li>\n</ul>\n</li>\n</ul><p><strong>params</strong> <code>Object</code> - A Javascript object containing the query <code>type</code> and <code>body</code></p><ul>\n<li><strong>type</strong> <code>String</code> - Document type</li>\n<li><strong>body</strong> <code>String</code> - A JSON object specifying a valid query in the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\">ElasticSearch Query DSL</a> format</li>\n</ul><p><span class=\"fa fa-info-circle\"></span> The <code>streamOnly</code> field parameter is deprecated starting v0.9.0 onwards, and is the default for how <code>searchStream()</code> works.</p><p><strong>Returns</strong></p><p><a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream.Readable</a> <code>Object</code> with</p><ul>\n<li><code>'data'</code> and <code>'error'</code> event handlers</li>\n<li>a <strong>stop()</strong> method to stop the stream</li>\n</ul>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"searchStream()"},{"content":"<h3 id=\"javascript-api-reference-streaming-data-searchstreamtourl\">searchStreamToURL()</h3><p>Continuously stream results of search query on a given <code>type</code> to a URL. <strong>searchStreamToURL()</strong> executes a webhook query on document insertion.</p><p><code>searchStreamToURL()</code> subscribes to search query results on new document inserts.</p><p><strong>Usage</strong></p><p><code>appbaseRef.searchStreamToURL(queryParams, urlParams)</code></p><ul>\n<li><p><strong>queryParams</strong> <code>Object</code> - A Javascript object containing the query <code>type</code> and <code>body</code></p>\n<ul>\n<li><strong>type</strong> <code>String</code> - Document type</li>\n<li><strong>body</strong> <code>String</code> - A JSON object specifying a valid query in the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\">ElasticSearch Query DSL</a> format</li>\n</ul>\n</li>\n<li><p><strong>urlParams</strong> <code>Object</code> - A Javascript object containing the <code>url</code> to which data would be streamed on a query match. It supports optional fields to attach JSON (or string) payloads, control the frequency and number of updates.</p>\n<ul>\n<li><strong>url</strong> <code>String</code> - A URL string</li>\n<li><strong>body</strong> <code>Object</code> - A JSON object to be sent to the URL (used as an alternative to <strong>string_body</strong>)</li>\n<li><strong>string_body</strong> <code>String</code> - A raw string to be sent to the URL (used as an alternative to <strong>body</strong>)</li>\n<li><strong>count</strong> <code>Number</code> - # of times the result-request should be sent before terminating the webhook</li>\n<li><strong>interval</strong> <code>Number</code> - Wait duration in seconds before the next result-request</li>\n</ul>\n</li>\n</ul><p><strong>queryParams</strong> <code>Object</code> - A Javascript object containing the query <code>type</code> and <code>body</code></p><ul>\n<li><strong>type</strong> <code>String</code> - Document type</li>\n<li><strong>body</strong> <code>String</code> - A JSON object specifying a valid query in the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\">ElasticSearch Query DSL</a> format</li>\n</ul><p><strong>urlParams</strong> <code>Object</code> - A Javascript object containing the <code>url</code> to which data would be streamed on a query match. It supports optional fields to attach JSON (or string) payloads, control the frequency and number of updates.</p><ul>\n<li><strong>url</strong> <code>String</code> - A URL string</li>\n<li><strong>body</strong> <code>Object</code> - A JSON object to be sent to the URL (used as an alternative to <strong>string_body</strong>)</li>\n<li><strong>string_body</strong> <code>String</code> - A raw string to be sent to the URL (used as an alternative to <strong>body</strong>)</li>\n<li><strong>count</strong> <code>Number</code> - # of times the result-request should be sent before terminating the webhook</li>\n<li><strong>interval</strong> <code>Number</code> - Wait duration in seconds before the next result-request</li>\n</ul><p><span class=\"fa fa-star\"></span> <strong>body</strong> and <strong>string_body</strong> fields support <a href=\"http://mustache.github.io/mustache.5.html\">mustache syntax</a> for accessing values inside the matching result object.</p><p><strong>Returns</strong></p><p><a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream.Readable</a> <code>Object</code> with</p><ul>\n<li><code>'data'</code> and <code>'error'</code> event handlers</li>\n<li>a <strong>change()</strong> method to replace the destination URL object</li>\n<li>a <strong>stop()</strong> method to de-register the webhook</li>\n</ul><p><span class=\"fa fa-info-circle\"></span> We recommend using both <strong>change()</strong> and <strong>stop()</strong> methods inside the <code>data</code> or <code>error</code> event handlers due to the async nature of the <code>searchStreamToURL()</code> method.</p>","link":"./scalr/javascript/api-reference.html","spaLink":"#/scalr/javascript/api-reference","title":"searchStreamToURL()"},{"content":"<h1 id=\"quick-start-to-the-js-api\">Quick Start to the <img src=\"http://i.imgur.com/Eppz2lz.png?1\" alt=\"Scalr\"> JS API</h1><p><a href=\"https://github.com/appbaseio/appbase-js\">Appbase.JS</a> is a minimalistic library for data streams.  </p><p>It can:</p><ul>\n<li>Continuously stream updates to documents, queries or filters over <code>websockets</code>.</li>\n<li>Index new documents or update / delete existing ones.</li>\n</ul><p>It can’t:  </p><ul>\n<li>Configure mappings, change analyzers, or capture snapshots. All these are provided by <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html\">elasticsearch.js</a> - the official ElasticSearch JS client library.</li>\n</ul><p><a href=\"https://appbase.io\">Appbase</a> is opinionated about the cluster setup and doesn’t support the ElasticSearch devops APIs.</p><p>This is a quick start guide to whet the appetite with the possibilities of data streams.</p>","link":"./scalr/javascript/javascript-intro.html","spaLink":"#/scalr/javascript/javascript-intro","title":"QUICK START TO THE JS API"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-0-creating-an-app\">Step 0: Creating an App</h2><p><a href=\"https://imgflip.com/gif/opgl9\"><img src=\"https://i.imgflip.com/opgl9.gif\"></a><br>Log in to <span class=\"fa fa-external-link\"></span> <a href=\"http://appbase.io/scalr/\">Appbase Dashboard</a>, and create a new app.</p><p>For this tutorial, we will use an app called “createnewtestapp01”. The &lt;username&gt;:&lt;password&gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.</p><p>SCALR uses <em>HTTP Basic Auth</em>, a widely used protocol for a simple username/password authentication.</p>","link":"./scalr/javascript/javascript-intro.html","spaLink":"#/scalr/javascript/javascript-intro","title":"STEP 0: CREATING AN APP"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-1-lib-setup\">Step 1: Lib Setup</h2><p>We will fetch and install the <strong>appbase-js</strong> lib using <a href=\"http://bower.io\">bower</a>. We will use <code>v0.10.1</code> for specificity. </p><p>Requiring the lib takes just one line of html script injection:</p><p>To write data or stream updates from <a href=\"https://appbase.io\">appbase.io</a>, we need to first create a reference object. We do this by passing the API URL, appname, and a username:password combination into the <code>Appbase</code> constructor:</p><p><strong>OR</strong></p><p>Alternatively, username:password can be passed as a part of the API URL in the constructor.</p>","link":"./scalr/javascript/javascript-intro.html","spaLink":"#/scalr/javascript/javascript-intro","title":"STEP 1: LIB SETUP"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-2-storing-data\">Step 2: Storing Data</h2><p>Once we have the reference object (called <code>appbaseRef</code> in this tutorial), we can insert any JSON object into it with the <code>index()</code> method.</p><p>where <code>type: 'books'</code> indicate the collection (or table) inside which the data will be stored and the<code>id: '1'</code> is an optional unique identifier.</p><p>The <code>index()</code> method (and all the other <code>appbase</code> methods) return a <a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream</a> object. A ‘data’ event handler can be used on the returned object (or in a chained fashion) for listening to all the data changes.</p><p><span class=\"fa fa-info-circle\"></span> If you have noticed, SCALR uses the same APIs and data modeling conventions as <a href=\"https://www.elastic.co/products/elasticsearch\">ElasticSearch</a>. A <strong>type</strong> is equivalent to a <em>collection in MongoDB</em> or a <em>table in SQL</em>, and a document is similar to the document in MongoDB and equivalent to a <em>row in SQL</em>.</p>","link":"./scalr/javascript/javascript-intro.html","spaLink":"#/scalr/javascript/javascript-intro","title":"STEP 2: STORING DATA"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-3-geting-vs-streaming-data\">Step 3: <s>GETing</s> vs Streaming Data</h2><p>Unlike typical databases that support GET operations (or Read) for fetching data and queries, Appbase.io operates on both GET and stream modes. We will first apply the GET mode to read our just inserted object.</p><p>Now that we are able to store data, let’s try to get the data back from <a href=\"https://appbase.io\">appbase.io</a> with the <code>get()</code> method.</p><p>Even though <code>get()</code> returns a single document data, appbase.io returns it as a stream object with the ‘data’ event handler.</p><p>Let’s say that we are interested in subscribing to all the state changes that happen on a document. Here, we would use the <code>getStream()</code> method over <code>get()</code>, which keeps returning new changes made to the document.</p>","link":"./scalr/javascript/javascript-intro.html","spaLink":"#/scalr/javascript/javascript-intro","title":"STEP 3: GETING VS STREAMING DATA"},{"content":"<h3 id=\"quick-start-to-the-js-api-step-3-geting-vs-streaming-data-3a-subscribing-to-document-stream\">3.a: Subscribing to document stream</h3><p>Don’t be surprised if you don’t see anything printed, <code>getStream()</code> only returns when new updates are made to the document.</p>","link":"./scalr/javascript/javascript-intro.html","spaLink":"#/scalr/javascript/javascript-intro","title":"3.a: Subscribing to document stream"},{"content":"<h3 id=\"quick-start-to-the-js-api-step-3-geting-vs-streaming-data-3b-observe-the-updates-in-realtime\">3.b: Observe the updates in realtime</h3><p>Let’s see live updates in action. We will modify the book price in our original <code>jsonObject</code> variable from 5595 to 6034 and apply <code>index()</code> again.</p><p>For brevity, we will not show the <code>index()</code> operation here.</p><p>In the new document update, we can see the price change (5595 -&gt; 6034) being reflected. Subsequent changes will be streamed as JSON objects.</p><p><code>Note:</code> Appbase always streams the final state of an object, and not the diff b/w the old state and the new state. You can compute diffs on the client side by persisting the state using a composition of (_type, _id) fields.</p>","link":"./scalr/javascript/javascript-intro.html","spaLink":"#/scalr/javascript/javascript-intro","title":"3.b: Observe the updates in realtime"},{"content":"<h2 id=\"quick-start-to-the-js-api-step-4-streaming-rich-queries\">Step 4: Streaming Rich Queries</h2><p>Streaming document updates are great for building messaging systems or notification feeds on individual objects. What if we were interested in continuously listening to a broader set of data changes? The <code>searchStream()</code> method scratches this itch perfectly. </p><p>In the example below, we will see it in action with a <code>match_all</code> query that returns any time a new document is added to the type ‘books’ or when any of the existing documents are modified.</p><p><code>Note:</code> Like <code>getStream()</code>, <code>searchStream()</code> subscribes to the new matches. For fetching existing search results, check out <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-getting-data-search\"><code>search()</code></a>.</p><p><strong>v0.10.0</strong> introduces a new method <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-streaming-data-searchstreamtourl\"><code>searchStreamToURL()</code></a> that streams results directly to a URL instead of streaming back.</p><p>In this tutorial, we have learnt how to index new data and stream both individual data and results of an expressive query. <a href=\"https://appbase.io\">Appbase.io</a> supports a wide range of queries.</p><p>For next steps, check out our <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html\">Javascript API reference</a>.</p>","link":"./scalr/javascript/javascript-intro.html","spaLink":"#/scalr/javascript/javascript-intro","title":"STEP 4: STREAMING RICH QUERIES"},{"content":"<h1 id=\"webhooks-guide\">Webhooks Guide</h1><p>Webhooks (aka streaming to a URL) allows you to set up integrations which respond to events in appbase.io. Webhooks can be used to send transaction emails, post on a slack channel when a new user signs up, update the pricing plan when the data storage crosses a threshold.</p>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"WEBHOOKS GUIDE"},{"content":"<h2 id=\"webhooks-guide-how-webhooks-are-triggered\">How webhooks are triggered</h2><p>Webooks are continuous queries whose results are subscribed by a URL. A webhooks object contains 1) continuous query and 2) subscribed URL’s configurations (headers, body payload, count, interval).</p><p>Webhooks can be triggered when a new document is inserted, an existing document changes it’s value, or when a new document matches a specific continuous query condition.</p>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"HOW WEBHOOKS ARE TRIGGERED"},{"content":"<h2 id=\"webhooks-guide-composing-webhooks-queries\">Composing Webhooks Queries</h2><p>Since registering a webhook is a method of the <code>Appbase</code> object, we will start with instantiating an Appbase object.</p><p>Webhooks in appbase-js are supported by <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-streaming-data-searchstreamtourl\"><code>searchStreamToURL()</code></a>. The behavior is very similar to  <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-streaming-data-searchstream\"><code>searchStream()</code></a>, where the results are subscribed via a streams interface. Instead of subscribing the results back to the user, webhooks subscribe them to a URL.</p><p>Here, we set the webhook request to be sent every time there is a document insert in the <code>type</code> tweet. To control for the noise, we set the <code>interval</code> to 60s.</p>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"COMPOSING WEBHOOKS QUERIES"},{"content":"<h3 id=\"webhooks-guide-composing-webhooks-queries-modifying-a-webhooks-url\">Modifying a Webhook’s URL</h3><p>The <code>searchStreamToURL()</code> method returns a stream object with a method <code>change()</code> which can be used to change the webhook’s subscribed URL for the original continuous query.</p><p><code>change(object)</code> method accepts a URL object which completely replaces the previous URL object.</p>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"Modifying a Webhook’s URL"},{"content":"<h3 id=\"webhooks-guide-composing-webhooks-queries-deregistering-the-webhook-query\">Deregistering the Webhook Query</h3><p>The <code>searchStreamToURL()</code> method returns a stream object with a method <code>stop()</code> which deletes the webhook query.</p><p><code>stop()</code> method deletes the webhook query. It’s important to call this method only after the webhook is successfully registered.</p>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"Deregistering the Webhook Query"},{"content":"<h2 id=\"webhooks-guide-adding-dynamic-data-in-webhooks\">Adding Dynamic Data in Webhooks</h2><p>Webhooks in appbase.io are designed for configurability.</p><p>Together, these three features allow for a very versatile webhooks streaming. In this doc, we will look at composing webhook queries and a number of different usage scenarios for webhooks.</p>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"ADDING DYNAMIC DATA IN WEBHOOKS"},{"content":"<h3 id=\"webhooks-guide-adding-dynamic-data-in-webhooks-mustache-syntax\">Mustache Syntax</h3><p>One of the biggest uses of webhooks is sending transaction notifications, like sending an email or a push notification within the app. We support Mustache syntax for enabling sending dynamic data in webhook request’s body payload.</p>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"Mustache Syntax"},{"content":"<h2 id=\"webhooks-guide-usage-scenarios\">Usage Scenarios</h2>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"USAGE SCENARIOS"},{"content":"<h3 id=\"webhooks-guide-usage-scenarios-1-top-10-daily-recommendations\">1. Top 10 daily recommendations</h3>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"1. Top 10 daily recommendations"},{"content":"<h3 id=\"webhooks-guide-usage-scenarios-2-pricing-plan-change-and-notification\">2. Pricing plan change and notification</h3>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"2. Pricing plan change and notification"},{"content":"<h3 id=\"webhooks-guide-usage-scenarios-3-bitcoin-price-alert\">3. Bitcoin price alert</h3>","link":"./scalr/javascript/javascript-webhooks.html","spaLink":"#/scalr/javascript/javascript-webhooks","title":"3. Bitcoin price alert"},{"content":"<h1 id=\"meteor-api-quickstart\">Meteor API Quickstart</h1><p>Appbase is a minimalistic library for data streams.</p><p>It can:</p><ul>\n<li>Continuously stream updates to documents, queries or filters over websockets (for browsers) and http-streams.</li>\n<li>Index new documents or update / delete existing ones. </li>\n</ul><p>It can be added to a meteor project by running</p>","link":"./scalr/javascript/meteor-intro.html","spaLink":"#/scalr/javascript/meteor-intro","title":"METEOR API QUICKSTART"},{"content":"<h2 id=\"meteor-api-quickstart-using-it-client-side\">Using it client-side</h2><p>You can read the <a href=\"http://docs.appbase.io/scalr/javascript/javascript-intro.html\">Javascript</a> quick-start guide for basic usage. </p><p>The API reference for using the library client-side can be found <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html\">here</a>.</p>","link":"./scalr/javascript/meteor-intro.html","spaLink":"#/scalr/javascript/meteor-intro","title":"USING IT CLIENT-SIDE"},{"content":"<h2 id=\"meteor-api-quickstart-using-it-server-side\">Using it server-side</h2><p>First, create a new Appbase reference like you would on the client. </p><p>The only difference between the client and server libraries is that all methods on the server except <code>getStream</code> and <code>searchStream</code> are synchronous. </p>","link":"./scalr/javascript/meteor-intro.html","spaLink":"#/scalr/javascript/meteor-intro","title":"USING IT SERVER-SIDE"},{"content":"<h3 id=\"meteor-api-quickstart-using-it-server-side-creating-an-appbase-reference\">Creating an Appbase reference</h3>","link":"./scalr/javascript/meteor-intro.html","spaLink":"#/scalr/javascript/meteor-intro","title":"Creating an Appbase reference"},{"content":"<h3 id=\"meteor-api-quickstart-using-it-server-side-writing-data\">Writing data</h3><p>An example using the <code>index</code> method is given below. Other methods like <code>update</code>, <code>get</code>, <code>delete</code>, <code>search</code> and <code>searchStreamToURL</code> can be used in a similar manner. </p><p>Refer to the client-side <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html\">documentation</a> for the parameters they can take. </p><p>Writes a JSON data object at a given <code>type</code> and <code>id</code> location, or replaces if an object already exists.</p>","link":"./scalr/javascript/meteor-intro.html","spaLink":"#/scalr/javascript/meteor-intro","title":"Writing data"},{"content":"<h2 id=\"meteor-api-quickstart-streaming-data\">Streaming Data</h2><p>The streaming methods are <code>searchStream</code> and <code>getStream</code>.</p><p>Streaming is done in a similar way on both client and server. An example using <code>searchStream</code> is given below. </p>","link":"./scalr/javascript/meteor-intro.html","spaLink":"#/scalr/javascript/meteor-intro","title":"STREAMING DATA"},{"content":"<h3 id=\"meteor-api-quickstart-streaming-data-searchstream\">searchStream()</h3><p><code>searchStream()</code> subscribes to search results on new document inserts, existing search results can be fetched via <code>search()</code> method.</p><p>The reactive array used below can be installed using</p><p><strong>Returns</strong></p><p><a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream.Readable</a> <code>Object</code> with</p><ul>\n<li><code>'data'</code> and <code>'error'</code> event handlers</li>\n<li>a <strong>stop()</strong> method to stop the stream</li>\n</ul>","link":"./scalr/javascript/meteor-intro.html","spaLink":"#/scalr/javascript/meteor-intro","title":"searchStream()"},{"content":"<h1 id=\"quick-start-to-the-nodejs-api\">Quick Start to the <img src=\"http://i.imgur.com/Eppz2lz.png?1\" alt=\"Scalr\"> Node.JS API</h1><p><a href=\"https://github.com/appbaseio/appbase-js\">Appbase.JS</a> is a minimalistic library for data streams.  </p><p>It can:</p><ul>\n<li>Continuously stream updates to documents, queries or filters over <code>websockets</code>.</li>\n<li>Index new documents or update / delete existing ones.</li>\n</ul><p>It can’t:  </p><ul>\n<li>Configure mappings, change analyzers, or capture snapshots. All these are provided by <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html\">elasticsearch.js</a> - the official ElasticSearch JS client library.</li>\n</ul><p>Also, <a href=\"https://appbase.io\">Appbase</a> is opinionated about the cluster setup and doesn’t support the ElasticSearch devops APIs.</p><p>This is a quick start guide to whet the appetite with the possibilities of data streams.</p>","link":"./scalr/javascript/nodejs-intro.html","spaLink":"#/scalr/javascript/nodejs-intro","title":"QUICK START TO THE NODE.JS API"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-0-creating-an-app\">Step 0: Creating an App</h2><p><a href=\"https://imgflip.com/gif/opgl9\"><img src=\"https://i.imgflip.com/opgl9.gif\"></a><br>Log in to <span class=\"fa fa-external-link\"></span> <a href=\"http://appbase.io/scalr/\">Appbase Dashboard</a>, and create a new app.</p><p>For this tutorial, we will use an app called “createnewtestapp01”. The &lt;username&gt;:&lt;password&gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.</p><p>SCALR uses <em>HTTP Basic Auth</em>, a widely used protocol for a simple username/password authentication.</p>","link":"./scalr/javascript/nodejs-intro.html","spaLink":"#/scalr/javascript/nodejs-intro","title":"STEP 0: CREATING AN APP"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-1-lib-setup\">Step 1: Lib Setup</h2><p>We will fetch and install the <strong>appbase-js</strong> lib via <a href=\"https://www.npmjs.com/package/appbase-js\">npm</a>, current version should be v0.10.1.</p><p>Requiring the lib takes one line:</p><p>To write data or stream updates from <a href=\"https://appbase.io\">appbase.io</a>, we need to first create a reference object. We do this by passing the API URL, appname, and a username:password combination into the <code>Appbase</code> constructor:</p><p><strong>OR</strong></p><p>Alternatively, username:password can be passed as a part of the API URL in the constructor.</p>","link":"./scalr/javascript/nodejs-intro.html","spaLink":"#/scalr/javascript/nodejs-intro","title":"STEP 1: LIB SETUP"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-2-storing-data\">Step 2: Storing Data</h2><p>Once we have the reference object (called <code>appbaseRef</code> in this tutorial), we can insert any JSON object into it with the <code>index()</code> method.</p><p>where <code>type: 'books'</code> indicate the collection (or table) inside which the data will be stored and the<code>id: '1'</code> is an optional unique identifier.</p><p>The <code>index()</code> method (and all the other <code>appbase</code> methods) return a <a href=\"https://nodejs.org/api/stream.html#stream_class_stream_readable\">stream</a> object. A ‘data’ event handler can be used on the returned object (or in a chained fashion) for listening to all the data changes.</p><p><span class=\"fa fa-info-circle\"></span> If you have noticed, SCALR uses the same APIs and data modeling conventions as <a href=\"https://www.elastic.co/products/elasticsearch\">ElasticSearch</a>. A <strong>type</strong> is equivalent to a <em>collection in MongoDB</em> or a <em>table in SQL</em>, and a document is similar to the document in MongoDB and equivalent to a <em>row in SQL</em>.</p>","link":"./scalr/javascript/nodejs-intro.html","spaLink":"#/scalr/javascript/nodejs-intro","title":"STEP 2: STORING DATA"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-3-geting-vs-streaming-data\">Step 3: <s>GETing</s> vs Streaming Data</h2><p>Unlike typical databases that support GET operations (or Read) for fetching data and queries, Appbase.io operates on both GET and stream modes. We will first apply the GET mode to read our just inserted object.</p><p>Now that we are able to store data, let’s try to get the data back from <a href=\"https://appbase.io\">appbase.io</a> with the <code>get()</code> method.</p><p>Even though <code>get()</code> returns a single document data, appbase.io returns it as a stream object with the ‘data’ event handler.</p><p>Let’s say that we are interested in subscribing to all the state changes that happen on a document. Here, we would use the <code>getStream()</code> method over <code>get()</code>, which keeps returning new changes made to the document.</p>","link":"./scalr/javascript/nodejs-intro.html","spaLink":"#/scalr/javascript/nodejs-intro","title":"STEP 3: GETING VS STREAMING DATA"},{"content":"<h3 id=\"quick-start-to-the-nodejs-api-step-3-geting-vs-streaming-data-3a-subscribing-to-document-stream\">3.a: Subscribing to document stream</h3><p>Don’t be surprised if you don’t see anything printed, <code>getStream()</code> only returns when new updates are made to the document.</p>","link":"./scalr/javascript/nodejs-intro.html","spaLink":"#/scalr/javascript/nodejs-intro","title":"3.a: Subscribing to document stream"},{"content":"<h3 id=\"quick-start-to-the-nodejs-api-step-3-geting-vs-streaming-data-3b-observe-the-updates-in-realtime\">3.b: Observe the updates in realtime</h3><p>Let’s see live updates in action. We will modify the book price in our original <code>jsonObject</code> variable from 5595 to 6034 and apply <code>index()</code> again.</p><p>For brevity, we will not show the <code>index()</code> operation here.</p><p>In the new document update, we can see the price change (5595 -&gt; 6034) being reflected. Subsequent changes will be streamed as JSON objects.</p><p><code>Note:</code> Appbase always streams the final state of an object, and not the diff b/w the old state and the new state. You can compute diffs on the client side by persisting the state using a composition of (_type, _id) fields.</p>","link":"./scalr/javascript/nodejs-intro.html","spaLink":"#/scalr/javascript/nodejs-intro","title":"3.b: Observe the updates in realtime"},{"content":"<h2 id=\"quick-start-to-the-nodejs-api-step-4-streaming-rich-queries\">Step 4: Streaming Rich Queries</h2><p>Streaming document updates are great for building messaging systems or notification feeds on individual objects. What if we were interested in continuously listening to a broader set of data changes? The <code>searchStream()</code> method scratches this itch perfectly. </p><p>In the example below, we will see it in action with a <code>match_all</code> query that returns any time a new document is added to the type ‘books’ or when any of the existing documents are modified.</p><p><code>Note:</code> Like <code>getStream()</code>, <code>searchStream()</code> subscribes to the new matches. For fetching existing search results, check out <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-getting-data-search\"><code>search()</code></a>.</p><p><strong>v0.10.0</strong> introduces a new method <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html#javascript-api-reference-streaming-data-searchstreamtourl\"><code>searchStreamToURL()</code></a> that streams results directly to a URL instead of streaming back.</p><p>In this tutorial, we have learnt how to index new data and stream both individual data and results of an expressive query. <a href=\"https://appbase.io\">Appbase.io</a> supports a wide range of queries.</p><p>For next steps, check out our <a href=\"http://docs.appbase.io/scalr/javascript/api-reference.html\">Javascript API reference</a>.</p>","link":"./scalr/javascript/nodejs-intro.html","spaLink":"#/scalr/javascript/nodejs-intro","title":"STEP 4: STREAMING RICH QUERIES"},{"content":"<h1 id=\"quick-start-to-the-rest-api\">Quick Start to the <img src=\"http://i.imgur.com/a1KAate.png\" alt=\"Scalr\"> REST API:</h1>","link":"./scalr/rest/intro.html","spaLink":"#/scalr/rest/intro","title":"QUICK START TO THE  REST API:"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-0-creating-an-app\">Step 0: Creating an App</h2><p><a href=\"https://imgflip.com/gif/opgl9\"><img src=\"https://i.imgflip.com/opgl9.gif\"></a><br>Log in to <span class=\"fa fa-external-link\"></span> <a href=\"http://appbase.io/scalr/\">Appbase Dashboard</a>, and create a new app.</p><p>For this tutorial, we will use an app called “createnewtestapp01”. The &lt;username&gt;:&lt;password&gt; combination for this app is RIvfxo1u1:dee8ee52-8b75-4b5b-be4f-9df3c364f59f.</p><p>SCALR uses <em>HTTP Basic Auth</em>, a widely used protocol for simple username/password authentication. This is similar to how GitHub’s authentication works over <code>https</code>, just imagine every repository (app in our context) having it’s unique &lt;username&gt;:&lt;password&gt; combination.</p>","link":"./scalr/rest/intro.html","spaLink":"#/scalr/rest/intro","title":"STEP 0: CREATING AN APP"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-1-making-requests\">Step 1: Making Requests</h2><p>Here’s an example authenticated <code>GET</code> request. We will set the app name, username and password as bash variables and reuse them in the requests.</p>","link":"./scalr/rest/intro.html","spaLink":"#/scalr/rest/intro","title":"STEP 1: MAKING REQUESTS"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-1-storing-data\">Step 1: Storing Data</h2><p>Let’s insert a JSON object. We create a <strong>type</strong> <code>books</code> inside our app and add a JSON document <code>1</code> with a PUT request.</p><p>If you have noticed, SCALR uses the same APIs as <a href=\"https://www.elastic.co/products/elasticsearch\">ElasticSearch</a>. A <strong>type</strong> is equivalent to a <em>collection in MongoDB</em> or a <em>table in SQL</em>, and a document is similar to the document in MongoDB and equivalent to a <em>row in SQL</em>.</p>","link":"./scalr/rest/intro.html","spaLink":"#/scalr/rest/intro","title":"STEP 1: STORING DATA"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-2-geting-err-streaming-data\">Step 2: <s>GETing</s> err, Streaming Data</h2><p>Getting live updates to a document is as simple as suffixing <code>?stream=true</code> to a GET request. It’s so awesome that we recommend using this as the default way to GET things.</p><p>Appbase.io keeps an open connection so that every time there is an update in the <code>/$app/books/1</code> document, it is streamed via the connection.</p>","link":"./scalr/rest/intro.html","spaLink":"#/scalr/rest/intro","title":"STEP 2: GETING ERR, STREAMING DATA"},{"content":"<h3 id=\"quick-start-to-the-rest-api-step-2-geting-err-streaming-data-step-2a-modify-the-document\">Step 2.a: Modify the Document</h3><p>Let’s modify the book price to 6034.</p>","link":"./scalr/rest/intro.html","spaLink":"#/scalr/rest/intro","title":"Step 2.a: Modify the Document"},{"content":"<h3 id=\"quick-start-to-the-rest-api-step-2-geting-err-streaming-data-step-2b-observe-the-streams\">Step 2.b: Observe the Streams</h3><p>In the new document update, we can see the price change (5595 -&gt; 6034) being reflected. Subsequent changes will be streamed to the resonse as raw JSON objects. As we see, there are no delimiters between between two consecutive JSON responses.</p><p>For every <code>?stream=true</code> request, Appbase.io keeps an open connection up to a max of 6 hrs.</p>","link":"./scalr/rest/intro.html","spaLink":"#/scalr/rest/intro","title":"Step 2.b: Observe the Streams"},{"content":"<h2 id=\"quick-start-to-the-rest-api-step-3-streaming-search\">Step 3: Streaming Search</h2><p>Streaming document updates seems straightforward, can we apply rich filters and queries to our streams? Yes, we can. We can specify any ElasticSearch Query DSL request, and get responses via streams.</p><p>We will see it here with a <code>match_all</code> query request.</p>","link":"./scalr/rest/intro.html","spaLink":"#/scalr/rest/intro","title":"STEP 3: STREAMING SEARCH"},{"content":"<h1 id=\"datamodel\">Datamodel</h1><p>Appbase is a realtime Database as a Service (DBaaS), built on top of a graph schema with JSON based vertices (similar to JSON documents), and edges to link them.</p><p>All databases support the storing and fetching of data, what distinguishes one database type from another is the structure of the data they store and the means by which it can be retrieved. </p><p>Several popular databases can be classified as below:</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"DATAMODEL"},{"content":"<h2 id=\"datamodel-data-in-appbase\">Data in Appbase</h2><p>Appbase is a <a href=\"http://en.wikipedia.org/wiki/Directed_graph\"><em>Directed Graph</em></a>. Objects inside Appbase are called <a href=\"http://en.wikipedia.org/wiki/Vertex_(graph_theory\">Vertices</a>) (a graph term for entities), and the links (relationships) between the objects are called <a href=\"http://en.wikipedia.org/wiki/Glossary_of_graph_theory#Basics\">Edges</a>.</p><p>Data in Appbase is stored as JSON objects. Appbase supports flexible schema, i.e. the properties of the JSON object need not be defined in advance. </p><p>Although Appbase supports storing embedded JSON objects and arrays, one doesn’t have to store data in this denormalized fashion. This is mainly for compatibility with existing document stores like MongoDB. The recommended approach is to create reference links between distint entities. In this doc, we will cover how you can store different kinds data (primitive values, objects, lists), create relationships amongst them, normalize, and do perform different queries on them.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"DATA IN APPBASE"},{"content":"<h2 id=\"datamodel-concepts\">Concepts</h2><p>Similar to how SQL has concepts for <em>table</em>, <em>row</em>, <em>column</em>, <em>relation</em> and MongoDB has <em>collection</em> , <em>Document</em> and <em>fields</em>, here are the key concepts in Appbase.</p><p><strong>Vertex</strong> — is similar to a <em>Document</em> in MongoDB, it stores data.  </p><ul>\n<li><strong>Key</strong> — A string that is used to access the vertex as an entry point.</li>\n<li><strong>Properties</strong> — A JSON object representing the data inside the vertex. </li>\n</ul><p><strong>Namespace</strong> — is similar to a <em>Collection</em> in MongoDB or <em>type</em> in ElasticSearch. A <em>vertex</em> always belongs to a <em>namespace</em> and <em>security rules</em> can be applied on <em>namespaces</em>. </p><p><strong>Edge</strong> — is a directional link to another vertex.  </p><ul>\n<li><strong>Priority</strong> — An <em>edge</em> can optionally have a priority, a <strong>Number</strong> (a secondary index).</li>\n<li><strong>outVertex</strong> — is the vertex which the edge points <em>to</em>.</li>\n<li><strong>inVertex</strong>  — the vertex <em>from</em> which the edge starts.</li>\n</ul><p>i.e. an <em>edge</em> is pointed from <em>inVertex</em> to an <em>outVertex</em>.</p><p><strong>Path</strong> — Every <em>vertex</em> in Appbase has a path, starting from the &lt;namespace&gt; and ending at the <em>vertex</em>, not unlike the UNIX path. A typical path looks like &lt;namespace&gt;/&lt;v1&gt;/&lt;v2&gt;/…/&lt;vn&gt;/.</p><p><strong>URL</strong> — It is a way to point to a <em>Path</em> in the REST API. Paths are prefixed with the Appbase API base URL, application’s name and the API version. Eg. <a href=\"https://api.appbase.io/chat_app/v2/&lt;path&gt;/\">https://api.appbase.io/chat_app/v2/&lt;path&gt;/</a>.</p><p>We can not actually compare these concepts with other kinds of databases, but it helps to understand Appbase if we compare the <em>usage practices</em>.</p><p>With this table in mind, lets understand how the concepts work.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"CONCEPTS"},{"content":"<h3 id=\"datamodel-concepts-vertex\">Vertex</h3><p>Vertex is the the standard data container in Appbase. A vertex can store a valid JSON object and be linked to other vertices via <em>edges</em>.</p><p>It can also store nested JSON objects and arrays, but this is only for convenience. In practice, vertices act as singular data entities, i.e. you store only the data relevant to a single entity in the real world. For e.g. a person’s age, name, height, sex can be stored in a single vertex, but the data of his belongings, like a book or a car is a completely different entity. This new entity will have properties of its own and they should be stored inside a new vertex. Later in this document, we will see how we can create a relation between these two entities.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Vertex"},{"content":"<h3 id=\"datamodel-concepts-namespace\">Namespace</h3><p>Namespaces are a way to combine <em>similar</em> entities. For eg. all vertices storing different users can be stored inside the <em>user</em> namespace and all the tweets (repreented as vertices) can be stored inside the <em>tweet</em> namespace. Since namespace is a logical container, different kinds of objects can be stored inside a single namespace. This allows searching for <em>similar vertices</em> and applying <em>security rules</em> with ease.</p><p>Namespaces are <em>searchable</em>. We are using the open-source <a href=\"http://www.elasticsearch.org/\">ElasticSearch</a> behind the scenes to support this use-case. See <a href=\"http://docs.appbase.io/docs/search.html\">this documentation</a> for a quick intro on how search works.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Namespace"},{"content":"<h3 id=\"datamodel-concepts-edge-one-to-one-relationships\">Edge (one-to-one relationships)</h3><p>After creating entities, its time to create relations amongst them via <em>edges</em>. </p><p>An edge is a <em>named</em> directional link connecting two vertices for a purpose, a <em>one-to-one relation</em>. For instance, a book has an author, a husband has wife and a child has a mother. The edges for these would be <em>book vertex</em> <code>--authouredBy-&gt;</code> <em>person vertex</em>, <em>man vertex</em> <code>--marriedTo-&gt;</code> <em>woman vertex</em>. </p><p>Edges are directional, so if you set the edge <em>man</em> <code>--marriedTo-&gt;</code> <em>woman</em>, it only tells us that the man is married to the woman, but it tells us nothing about woman’s relationship status. For that, another edge, <em>woman</em> <code>--marriedTo-&gt;</code> <em>man</em>, should be created.</p><p>Appbase only allows for unique edge names. The default behaviour is last-write-wins in case a new edge is created with an existing name. Edges have priorities which are rational numbers (think of the <code>Number</code> datatype in Javascript).</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Edge (one-to-one relationships)"},{"content":"<h3 id=\"datamodel-concepts-path\">Path</h3><p>Paths are the way to interact with vertices in Appbase. Paths are constructed with &lt;namespace&gt;/&lt;vertexKey&gt;/&lt;edgeName_1&gt;/…/&lt;edgeName_N&gt;/.</p><p>Creating edges create deeper <em>Paths</em>. Lets take the example of the movie Inception, the Oscar deserver lead actor Leonardo DiCaprio, and the director Christopher Nolan. Here are the vertices stored in Appbase:</p><ul>\n<li>Namespace: movie</li>\n<li>Vertex Key: inception</li>\n</ul><ul>\n<li>Namespace: person</li>\n<li>Vertex Key: dicaprio</li>\n</ul><ul>\n<li>Namespace: person</li>\n<li>Vertex Key: nolan</li>\n</ul><ul>\n<li>Namespace: person</li>\n<li>Vertex Key: emma</li>\n</ul><p>These vertices can be accessed with the following paths, as entry points in the graph:</p><p>Let’s create edges:</p><p><img src=\"http://i.imgur.com/2Asfr9r.png\" alt=\"\"></p><p>With these edge, we created these deeper paths:</p><p><code>movie/inception/leadActor</code> : points to the same vertex as <code>person/dicaprio</code></p><p><code>movie/inception/directedBy</code> : points to <code>person/nolan</code></p><p><code>person/nolan/marriedTo</code>: points to <code>person/emma</code></p><p>Here’s the <em>magic</em>, the path <code>movie/inception/directedBy/marriedTo</code> points directly to <code>person/emma</code></p><p>This means, modifying the data stored at <code>movie/inception/directedBy/marriedTo</code> will change the data of <code>person/emma</code> as they both are the same vertices.</p><p>Paths are powerful ways to point to the exact data you want to interact with. For e.g.  when you access the path <code>movie/inception/directedBy/marriedTo</code>, you are only interested in the vertex representing the person who is married to the director of Inception, and nothing else. You never access the data of the movie Inception, or the director.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Path"},{"content":"<h3 id=\"datamodel-concepts-url\">URL</h3><p>A URL is just another representation of a <em>Path</em>. REST API URL looks like this: <a href=\"https://api.appbase.io/&lt;app_name&gt;/v2/&lt;path&gt;/\">https://api.appbase.io/&lt;app_name&gt;/v2/&lt;path&gt;/</a>. </p><p>Assuming the Application’s name as <em>imdb</em>, URL for the path <em>movie/inception/directedBy/marriedTo</em> would be <code>https://api.appbase.io/imdb/v2/movie/inception/directedBy/marriedTo</code></p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"URL"},{"content":"<h2 id=\"datamodel-storing-data\">Storing Data</h2><p>Being a Graph, Appbase allows you to create any kind of data structures you want, you just need to know exactly how. Lets see how to store the practical data structures we used on daily basis.</p><p>The examples here use Appbase Javascript Library and if any of the method is confusing you, feel free to chekout the <a href=\"http://docs.appbase.io/#/v2.0/javascript/api-reference\">JS Documentation</a>.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"STORING DATA"},{"content":"<h3 id=\"datamodel-storing-data-primitive-data-and-json-objects\">Primitive Data and JSON Objects</h3><p>Numbers, Characters, Strings and Booleans, are stored as values of the properties inside a vertex. Dates can be converted into the milliseconds since epoch, and store them as Numbers. For eg. you want to store a the movie’s name, and its release year, you can store combine all of them as a JSON object and store it inside a vertex.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Primitive Data and JSON Objects"},{"content":"<h3 id=\"datamodel-storing-data-nested-json-objects\">Nested JSON Objects</h3><p>You can store nested objects directly inside a vertex. E.g.</p><p>This would work perfectly. Notice that you are not storing the director (Nolan) of Inception as a <em>different entity</em>, instead as a <em>property</em> of the movie itself. While this approach is sometimes handy, it limits you in terms of what you can do with Nolan. I.e. you will not be able to establish any direct relationships with Nolan, as it is not an entity in itself. For eg. Nolan is married to Emma, but there is no way to create a link between Nolan  and Emma, when it is stored as a nested object in Appbase.</p><p>A better to do this is store Nolan as a new vertex, and create an edge from Inception to Nolan. You can create another vertex for Emma create edges with Nolan. </p><p>We will create three edges here: </p><p>inception <code>--directedBy-&gt;</code> nolan</p><p>nolan <code>--marriedTo-&gt;</code> emma\nRecall that the edges are <em>directional</em>, so this 2nd edge only tells us that Nolan in married to Emma, but says nothing about Emma’s marital status. That’s why we create the third edge: </p><p>emma <code>--marriedTo-&gt;</code> nolan</p><p><img src=\"http://i.imgur.com/IipHJzL.png\" alt=\"\"></p><p>Notice that Inception directed by Nolan, is a One-to-One relationship. Nolan has directed many movies, and that’s a case of One-to-Many relationships. We see later how to create them in Appbase. </p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Nested JSON Objects"},{"content":"<h3 id=\"datamodel-storing-data-sets-one-to-many-relationship\">Sets (One-to-Many Relationship)</h3><p>A set makes sure that all the items in the list exist only once. Consider this example, the movies directed by Nolan. We will make only a small list here:  <code>[\"Interstellar\", \"Inception\", \"The Dark Night\", \"Memento\"]</code>. Clearly, it doesn’t make sense to have any of the movies twice in the this list.  Notice that this is a One-to-Many relationship here. <em>Nolan</em> (1) -&gt; <em>Movies</em> (N).</p><p>Operations on a single set are: addition, checking existence of an item, deletion and traversal. </p><p>Operations on multiple sets, like union and intersection can be emulated using single-set operations. For e.g.</p><p>Let’s see a practical set, the movies directed by Nolan. </p><p>In Appbase, the Set is a vertex, let’s create it.</p><p>Also the Items in the set are vertices.</p><p>Now we have Appbase Vertex References to the Set and the Items, lets go through different set operations.</p><p>Simply creating an edge from the Set to the Item. We will use the Primary Key (<code>inceptionRef.name()</code>) of the item as the name of the edge.</p><p>Here, the important thing is to keep the edge-name exactly as the Vertex Key. That way makes sure that every item will exist only once in the set. For e.g. if you try to add <code>inceptionRef</code> again in the set, it will just replace the old edge no extra edges will be created.</p><p>Keeping the edge-name same as the Vertex Key of the item, allows other operations as well, like deletion of an Item and checking where an Item exists.</p><p>Remove the edge from Set to the Item.</p><p>As we kept the edge name exactly as the Vertex Key, it means that we can use the Vertex Key to delete the edge as well.</p><p>It’s not possible to check via the Item’s data, if the item exists or not. The only way we can check, is using the Vertex Key/edge-name. We see that if there’s an edge, with its name as the Vertex Key. We use <code>outVertex()</code> and <code>isValid()</code> for that. I.e. we are checking if the path <code>set/moviesByNolan/&lt;movieVertexKey&gt;</code> is valid or not.</p><p>As all the items are the edges of the Set vertex, we simply fetch the edges of the Set vertex, and traverse through them.</p><p>See <em>Retrieving Data</em> section.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Sets (One-to-Many Relationship)"},{"content":"<h2 id=\"datamodel-retrieving-data\">Retrieving Data</h2><p>In a nutshell, Namspaces in Appbase have vertices, and vertices have properties, edges.</p><p>Data retrieval in Appbase happens via <em>realtime streams</em>. These streams allows you to fetch existing data, and then keep listening to new data as well.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"RETRIEVING DATA"},{"content":"<h3 id=\"datamodel-retrieving-data-properties\">Properties</h3><p>When you start listening to the properties of a vertex, you first get the existing properties, and then as the data keeps changing, the callback is called again with new properties.</p><p>Appbase gives you the properties data as a <em>snapshot</em>. The snapshots are immutable copies of the data stored in a vertex. Any changes you make in the snapshot will not be stored in Appbase. </p><p>If you don’t want to listen to the properties any more, you can turn the listener off with <code>inceptionRef.off()</code>.</p><p>For convenience, we have the method  <code>inceptionRef.once()</code> when you want to listen to daat just only once.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Properties"},{"content":"<h3 id=\"datamodel-retrieving-data-edges\">Edges</h3><p>Retrieving existing edges of a vertex is simple: just listen to _edge<em>added</em> event, which will return existing edges at first. When new edges are added, the callback will be fired for new edges as well.</p><p>Notice that the if there are ‘N’ number of existing edges, the callback will be called ‘N’ times.</p><p><code>eRef</code> here is the Appbase Reference to the outVertex, and <code>eSnap</code> is the snapshot of the edge. Edge Snapshot is the snapshot of the data stored with the edge and the out vertex, mainly the <em>priority</em> of the edge, and the properties of the out vertex. <code>eSnap.priority()</code> will give you the priority, and <code>eSnap.properties()</code> will give you properties.</p><p>With edge filters, it is possible to fetch only certain edges. It comes handy when there are large number of edges and you want to paginate them, or want to fetch only a particular edge.</p><p>When more than one filter is provided, they work as logical <code>AND</code> and only the edges matchihg all filters will be fetched. This is what each filter means:</p><p>Notice that:</p><ul>\n<li>Filters are a way to fetch existing edges, thus they work only with _edge<em>added</em> event</li>\n<li>Edges are always returned ordered according to their priorities</li>\n<li>When <em>endAt</em> &lt; <em>startAt</em>, edges are returned in reverse order</li>\n<li>You can NOT apply all the numeric filters (first four) to newly created edges, they are only for existing edges and it is NOT possible to apply filters to newly created edges in realtime<ul>\n<li>This means that the numeric filters can not be used with <em>onlyNew</em> set to be <code>true</code></li>\n<li><em>Newly created</em> edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</li>\n</ul>\n</li>\n</ul><ul>\n<li>This means that the numeric filters can not be used with <em>onlyNew</em> set to be <code>true</code></li>\n<li><em>Newly created</em> edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</li>\n</ul>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Edges"},{"content":"<h3 id=\"datamodel-retrieving-data-vertices-in-a-namespace\">Vertices in a Namespace</h3><p>Namespaces are vertex containers, and it is possible to retrieve existing vertices, and listen to updates when new vertices are added or old vertices are removed.</p><p>The callback attached with _vertex<em>added</em> event is called for all the existing vertices. As new vertices are added, it is called for them too.</p><p>To listen to updates of vertex removal, use _vertex<em>removed</em> event.</p><p>With ElasticSearch’s powerful APIs in the backend, Appbase supports full-text fuzzy search queries on the data stored into vertices of a namespace. A sample query on a namespace looks something like this: </p><p>This query searches on all the vertices of the namespace <em>movie</em>, and returns an array of vertices who’s property <code>year</code>, matches fuzzily with the text “2010”. See <a href=\"http://docs.appbase.io/docs/search.html\">this documentation</a> for more details.</p>","link":"./v2.0/concepts/datamodel.html","spaLink":"#/v2.0/concepts/datamodel","title":"Vertices in a Namespace"},{"content":"<h1 id=\"ng-appbase-guide\">ng-Appbase Guide</h1><p>Appbase provides a realtime graph backend, is designed to write complex applications completely clientside. Appbase fits perfectly as a backend in your AngularJS application.</p><p>ngAppbase - AngularJS binding for Appbase, makes it very simple to bind your data between AngularJS and Appbase backend.</p><p><a href=\"http://appbase.io/tutorial.html\">Here</a>‘s a quick tutorial for Appbase JS api.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"NG-APPBASE GUIDE"},{"content":"<h2 id=\"ng-appbase-guide-integrating-the-awesome\">Integrating the awesome</h2><p>Add these script tags in your HTML:</p><p>Register <code>ngAppbase</code> as a dependency in the module, and the <code>$appbase</code> is available to be injected into any controller, service, or factory.</p><p><code>$appbase</code>, has the same methods as <code>Appbase</code> object exposed by the Appbase Javascript library. The difference is, when Appbase refrences (namespace and vertex) are created using <code>$appbase</code>, they have extra methods which allows binding your data with scope variables in Angular.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"INTEGRATING THE AWESOME"},{"content":"<h2 id=\"ng-appbase-guide-binding-objects\">Binding Objects</h2><p>As Angular binds the data between JS models and the DOM, ngAppbase propagates any changes the data from Appbase. This way, any changes to Appbase automatically appears in the DOM.\nNotice that, the changes in the JS model are <em><strong>not</strong></em> automatically sent to Appbase backend.</p><p><code>bindProperties</code> creates such a synchronized object, by binding properties of a vertex in Appbase, to a variable in JS.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"BINDING OBJECTS"},{"content":"<h3 id=\"ng-appbase-guide-binding-objects-example\">Example:</h3><p>Assume the properties of the vertex at <strong>‘user/bella’</strong> : </p><p>To bind this data to your view,\nJS:</p><p>HTML:</p><p>As Appbase notifies for data changes in realtime, if the data at <strong>‘user/bella’</strong> changes, i.e. if <code>$appbase.ns('user').v('bella').setData({having: 'Cerveja'})</code> is called, this change will be reflected in the scope variable instantly, and Angular will update the view.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"Example:"},{"content":"<h2 id=\"ng-appbase-guide-binding-arrays\">Binding Arrays</h2><p><code>ng-repeat</code> in AngularJS binds a list in DOM to an array model in JS, and this array can be bound to the <em>edges</em> of a <strong>vertex</strong>, or <em>vertices</em> in a <strong>namespace</strong> in Appbase, using <code>bindEdges</code> and <code>bindVertices</code>.</p><p>When edges or vertices are added, removed, replaced, or the priority is changed, these changes appear in the DOM in realtime.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"BINDING ARRAYS"},{"content":"<h3 id=\"ng-appbase-guide-binding-arrays-example\">Example</h3><p>Data in the out vertex pointed by the edge:</p><p>To bind this data into you view:\nJS:</p><p>HTML:</p><p>The same way, you can bind vertices under a namespace, as an array.</p><p>JS:</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"Example"},{"content":"<h2 id=\"ng-appbase-guide-modifying-data\">Modifying data</h2><p>Vertex References created with <code>$appbase.ns().v()</code> has all the methods exactly as the Appbase Javascript API. You can use methods <code>setData()</code> and <code>setEdge()</code> to modify the data.</p><p>The  documentation for Appbase JS api is <a href=\"http://docs.appbase.io/docs/js.html\">here</a>.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"MODIFYING DATA"},{"content":"<h2 id=\"ng-appbase-guide-next-steps\">Next Steps</h2><p>Checkout additional documentation for <code>bindEdges()</code>, <code>bindVertices()</code> and <code>bindProperties()</code> further down on this page.</p><p>Checkout this opensource <a href=\"http://twitter.appbase.io/\">Twitter clone</a> we built using this Angular binding in under ~250 lines of javascript code.</p><p>Have a great time building awesome realtime applications!</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"NEXT STEPS"},{"content":"<h1 id=\"appbase-api-docs\">$appbase API Docs</h1>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"$APPBASE API DOCS"},{"content":"<h2 id=\"appbase-api-docs-vertexrefbindedges\">vertexRef.bindEdges()</h2>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"VERTEXREF.BINDEDGES()"},{"content":"<h3 id=\"appbase-api-docs-vertexrefbindedges-returns\">Returns</h3><p>An <strong>array</strong> of edges, <em>sorted</em> by the <strong>priority</strong> of edges.\nEach object (called <em>edgeData</em> from now on) in array represents an edge and contains this data:</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"Returns"},{"content":"<h3 id=\"appbase-api-docs-vertexrefbindedges-arguments\">Arguments</h3><ul>\n<li><strong>scope</strong> : The angular scope where bindEdges() is called.</li>\n<li><strong>onAdd</strong> <em>(function)</em>: called when an edge is added. This function basically gives the programmer a facility to modify what should be available in <code>edgeData</code>. You can add more data into it, which will be automatically added in to the array, which bound to a scope variable, you don’t need to manually add any data to the scope.  The <code>edgeRef</code> passed in the callback helps fetching more data relevant to the edge. <code>done()</code> should be called when the required data is added in <code>edgeData</code>, only after that the <code>edgeData</code> will added in the array.</li>\n<li><strong>onComplete</strong> <em>(function)</em>: called when existing edges are fired. Works exactly as <code>onComplete</code> callback for _edge<em>added</em> event in Appbase Javascript Library.</li>\n<li><strong>onRemove</strong> <em>(function)</em>: called when an edge is removed. To remove the <code>edgeData</code> from the array, calling <code>done()</code> is necessary.</li>\n<li><strong>onChange</strong> <em>(function)</em>: called when the properties of the vertex are changed. To reflect the changes in the scope, calling <code>done()</code> is necessary.</li>\n<li><strong>onUnbind</strong> <em>(function)</em>: called when the scope variable is unbound from edges. You should turn off the listeners here, if added any in the <code>onAdd</code> callback.</li>\n</ul><p>Note that the vertex references returned in the callback, also have the methods <code>bindProperties</code> and <code>bindEdges</code>. Using <code>onAdd</code> callback and these methods, you can bind multiple level of edges.</p><p>Eg.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"Arguments"},{"content":"<h2 id=\"appbase-api-docs-bindvertices\">bindVertices()</h2><p><code>bindVertices</code> works exactly as <code>bindEdges</code>, except that it is invoked on a namespace reference and returns an array of all the vertices in the namespace. Callbacks <em>onAdd</em>, <em>onRemove</em> and <em>onChange</em> are called, respectively, when a vertex is added, destroyed and properties are changed. <em>onComplete</em> is called when existing vertices are retrieved. Works exactly as <code>onComplete</code> callback for <em>vertex_added</em> event in Appbase Javascript Library.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"BINDVERTICES()"},{"content":"<h2 id=\"appbase-api-docs-bindproperties\">bindProperties()</h2>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"BINDPROPERTIES()"},{"content":"<h3 id=\"appbase-api-docs-bindproperties-returns\">Returns</h3><p>An <strong>object</strong> , containing <em>properties</em> of the vertex as key-value pairs.</p>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"Returns"},{"content":"<h3 id=\"appbase-api-docs-bindproperties-arguments\">Arguments</h3><ul>\n<li><strong>scope</strong> : The angular scope where bindEdges() is called.</li>\n<li><strong>onProperties</strong> <em>(function)</em>: called when the properties are received/updated from server </li>\n<li><strong>onUnbind</strong> <em>(function)</em>: called when the scope variable is unbound. You should turn off the listeners here, if added any in the <code>onProperties</code> callback.</li>\n</ul>","link":"./v2.0/javascript/angular.html","spaLink":"#/v2.0/javascript/angular","title":"Arguments"},{"content":"<h1 id=\"introduction\">Introduction</h1><p>The Appbase JS library allows developers to create realtime multi-user apps using a graph data model and realtime smart-search capabilities.</p><p>To use it in the browser, use this link: <a href=\"https://cdn.appbase.io/latest/appbase.js\">https://cdn.appbase.io/latest/appbase.js</a></p><p>To use it with nodejs, do <code>npm install appbasejs</code></p><p>The Appbase library exposes the <code>Appbase</code> object. The methods in the JS lib rely on three main objects.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"INTRODUCTION"},{"content":"<h1 id=\"appbase\">Appbase</h1><p><strong>Appbase</strong> is the global object exposed the JS library. It has the following four methods: <code>credentials()</code>, \n<code>ns()</code>, <code>uuid()</code>, and <code>serverTime()</code>.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"APPBASE"},{"content":"<h2 id=\"appbase-setting-up\">Setting up</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"SETTING UP"},{"content":"<h3 id=\"appbase-setting-up-credentials\">credentials()</h3><p>Authorize the app credentials using the appname and appsecret identifiers, as they appear in the <a href=\"//appbase.io/developer\">Dev Console</a>.</p><p><strong>Usage</strong></p><p><code>Appbase.credentials(appname, [appsecret , onComplete])</code></p><ul>\n<li><strong>appname</strong> <code>String</code> — App name</li>\n<li><strong>appsecret</strong> <code>String</code> (optional) — App secret key\n  While using Appbase clientside, app secret should not be used, as it will be exposed in the Javascript file. <a href=\"http://docs.appbase.io/#/v2.0/javascript/oauth\">User Authentication</a> is recommended in the clientside use of Appbase Library.</li>\n<li><p><strong>onComplete</strong> <code>Function</code> — will be passed two arguments:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if event listening is successful</li>\n<li><strong>isAuthorized</strong> <code>Boolean</code> — Whether the credentials are correct or not</li>\n</ul>\n</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> — will be passed two arguments:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if event listening is successful</li>\n<li><strong>isAuthorized</strong> <code>Boolean</code> — Whether the credentials are correct or not</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"credentials()"},{"content":"<h2 id=\"appbase-namespaces\">Namespaces</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"NAMESPACES"},{"content":"<h3 id=\"appbase-namespaces-ns\">ns()</h3><p>Get the namespace reference with the passed <em>string identifier</em>. It creates a new namespace if one doesn’t already exist, else returns reference to the existing namespace. See <em>Namespace Reference</em> docs for how namespaces work.</p><p><strong>Usage</strong></p><p><code>Appbase.ns(namespace)</code></p><ul>\n<li><strong>namespace</strong> <code>String</code> — Namespace identifier (can contain all ascii characters except for whitespaces, ‘/’, ‘:’, and ‘~’.)</li>\n</ul><p><strong>Returns</strong></p><p><code>Object</code> <strong>nsref</strong> <em>Namespace Reference</em></p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"ns()"},{"content":"<h2 id=\"appbase-fantastic-search\">Fantastic Search</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"FANTASTIC SEARCH"},{"content":"<h3 id=\"appbase-fantastic-search-rawsearch\">rawSearch()</h3><p>Appbase uses ElasticSearch in the backend. To completely understand how it works, please refer to <a href=\"http://docs.appbase.io/docs/elasticsearch.html\">this page</a>.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"rawSearch()"},{"content":"<h2 id=\"appbase-utility\">Utility</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"UTILITY"},{"content":"<h3 id=\"appbase-utility-uuid\">uuid()</h3><p>Returns a 32-character uuid.</p><p><strong>Usage</strong></p><p><code>Appbase.uuid()</code></p><p><strong>Returns</strong></p><p><code>String</code> UUID</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"uuid()"},{"content":"<h3 id=\"appbase-utility-servertime\">serverTime()</h3><p>Obtain the current time in <em>milliseconds</em> since epoch.</p><p><strong>Usage</strong></p><p><code>Appbase.serverTime(onComplete)</code></p><ul>\n<li><p><strong>onComplete</strong> <code>Function</code> will be passed with two arguments.</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>serverTime()</code> returns successfully.</li>\n<li><strong>time</strong> <code>Number</code> — the current time of server in  milliseconds since epoch</li>\n</ul>\n</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> will be passed with two arguments.</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>serverTime()</code> returns successfully.</li>\n<li><strong>time</strong> <code>Number</code> — the current time of server in  milliseconds since epoch</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"serverTime()"},{"content":"<h1 id=\"namespace-reference\">Namespace Reference</h1><p>Namespace Reference Object or <code>nsref</code> has methods for creating vertices, searching vertices, and event listeners to the addition and removal of vertices.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"NAMESPACE REFERENCE"},{"content":"<h2 id=\"namespace-reference-vertices\">Vertices</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"VERTICES"},{"content":"<h3 id=\"namespace-reference-vertices-v\">v()</h3><p>Creates a new vertex or obtains a reference to an existing vertex.</p><p><strong>Usage</strong></p><p><code>nsref.v(path)</code></p><ul>\n<li><strong>path</strong> <code>String</code> — Relative path of the vertex reference. If creating a new vertex, this is the vertex identifier. <code>/</code> character is used for separating path variables. The path can contain all ascii characters except for whitespaces, ‘:’, and ‘~’.</li>\n</ul><p><strong>Returns</strong></p><p><strong>vref</strong> <code>Object</code> <em>Vertex Reference</em></p><p><code>Note:</code> Use a string identifier if you are creating a new vertex. A new vertex cannot be created recursively, avoid using non-existent paths.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"v()"},{"content":"<h2 id=\"namespace-reference-search\">Search</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"SEARCH"},{"content":"<h3 id=\"namespace-reference-search-search\">search()</h3><p>Powerful realtime search on vertices inside a namespace, with options to search using one or more data properties. It returns not just matched strings, but all the matching vertices.</p><p><strong>Note:</strong> Search has to be manually enabled on the namesapces using the <a href=\"http://appbase.io/developer\">Developer Dashboard</a>.</p><p><strong>Usage</strong></p><p><code>nsref.search(queryObj, onComplete)</code></p><ul>\n<li><p><strong>queryObj</strong> <code>Object</code> — A Javascript Object containing the following fields and values</p>\n<ul>\n<li><strong>text</strong> <code>String</code> — Search query string</li>\n<li><strong>properties</strong> <code>Array</code> — One or more properties on which to apply the search.</li>\n</ul>\n</li>\n<li><p><strong>onComplete</strong> <code>Function</code> — will be passed two arguments:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if event listening is successful</li>\n<li><strong>results</strong> <code>Array</code> — Search results as an Array of matching vertices.</li>\n</ul>\n</li>\n</ul><p><strong>queryObj</strong> <code>Object</code> — A Javascript Object containing the following fields and values</p><ul>\n<li><strong>text</strong> <code>String</code> — Search query string</li>\n<li><strong>properties</strong> <code>Array</code> — One or more properties on which to apply the search.</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> — will be passed two arguments:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if event listening is successful</li>\n<li><strong>results</strong> <code>Array</code> — Search results as an Array of matching vertices.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"search()"},{"content":"<h2 id=\"namespace-reference-retrieving-data\">Retrieving Data</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"RETRIEVING DATA"},{"content":"<h3 id=\"namespace-reference-retrieving-data-on\">on()</h3><p>Retrieve existing vertices, and listen to addition or removal of vertices.</p><p><strong>Usage</strong></p><p><code>nsref.on(eventType , callback [, onComplete])</code></p><ul>\n<li><strong>eventType</strong> <code>String</code> — Either “vertex_added” or “vertex_removed”</li>\n<li><p><strong>callback</strong> <code>Function</code> (optional) — is called when with existing vertices, and when ever a new vertex is added. It will be passed two arguments:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if event listening is successful</li>\n<li><strong>vref</strong> <code>Vertex Reference</code> — of the newly added vertex.</li>\n<li><strong>snapObj</strong> <code>Property Snapshot</code> — Snapshot of the data stored in the vertex. Take a look at the documentation of <code>Property Snapshot</code> on this page</li>\n</ul>\n</li>\n<li><p><strong>onComplete</strong> <code>Function</code> - Called when all the existing vertices have been retrieved. It will be called only once, with arguments:</p>\n<ul>\n<li><strong>nsref</strong> <code>Namespace Reference</code> — of the vertex where the edge is added.</li>\n</ul>\n</li>\n</ul><p><strong>callback</strong> <code>Function</code> (optional) — is called when with existing vertices, and when ever a new vertex is added. It will be passed two arguments:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if event listening is successful</li>\n<li><strong>vref</strong> <code>Vertex Reference</code> — of the newly added vertex.</li>\n<li><strong>snapObj</strong> <code>Property Snapshot</code> — Snapshot of the data stored in the vertex. Take a look at the documentation of <code>Property Snapshot</code> on this page</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> - Called when all the existing vertices have been retrieved. It will be called only once, with arguments:</p><ul>\n<li><strong>nsref</strong> <code>Namespace Reference</code> — of the vertex where the edge is added.</li>\n</ul><p><code>Note:</code> <code>vertex_added</code> event listener returns the existing vertices in the namespace when listening for the first time.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"on()"},{"content":"<h3 id=\"namespace-reference-retrieving-data-off\">off()</h3><p>Turn off the listeners on a given namespace reference.</p><p><code>nsref.off([eventType])</code></p><ul>\n<li><strong>eventType</strong> <code>String</code> (optional) — Either “vertex_added” or “vertex_removed”. Turns off all listeners on the reference if this argument is not passed.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"off()"},{"content":"<h2 id=\"namespace-reference-utility\">Utility</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"UTILITY"},{"content":"<h3 id=\"namespace-reference-utility-name\">name()</h3><p>Returns the name of the current reference.</p><p><strong>Usage</strong></p><p><code>nsref.name()</code></p><p><strong>Returns</strong></p><p><strong>name</strong> <code>String</code> Name of the <code>nsref</code>.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"name()"},{"content":"<h3 id=\"namespace-reference-utility-path\">path()</h3><p>Returns the path of the current reference.</p><p><strong>Usage</strong></p><p><code>nsref.path()</code></p><p>The method accepts no arguments, and returns a path of the <code>nsref</code> resource. Since namespaces are top-level objects, the path for a namespace is just the <em>namesapce identifier</em>.</p><p><strong>Returns</strong></p><p><strong>path</strong> <code>String</code> Path of the <code>nsref</code> is usually the namespace identifier.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"path()"},{"content":"<h3 id=\"namespace-reference-utility-url\">URL()</h3><p>Appbase URL of the current reference.</p><p><strong>Usage</strong></p><p><code>nsref.URL()</code></p><p>The method accepts no arguments, and returns a URL of the <code>nsref</code> resource.</p><p><strong>Returns</strong></p><p><strong>url</strong> <code>String</code> Data URL of the namespace reference. The format of the URL is <code>api.appbase.io/:appname/:version/namespace</code>.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"URL()"},{"content":"<h1 id=\"vertex-reference\">Vertex Reference</h1><p>Vertex Reference Object or <code>vref</code> has the methods for setting data, creating links to other vertices, and different listeners to notify about data changes, link changes, etc.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"VERTEX REFERENCE"},{"content":"<h2 id=\"vertex-reference-storing-data\">Storing Data</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"STORING DATA"},{"content":"<h3 id=\"vertex-reference-storing-data-setdata\">setData()</h3><p>Set one or more data properties on this vertex reference.</p><p><strong>Usage</strong></p><p><code>vref.setData(dataObject [, onComplete])</code></p><ul>\n<li><strong>dataObject</strong> <code>Object</code> — A valid JSON object. Can contain a nested object, or arrays.</li>\n<li><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>setData()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Object</code> — <em>Vertex Reference</em> of the vertex on which <code>setData()</code> has been applied.</li>\n</ul>\n</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>setData()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Object</code> — <em>Vertex Reference</em> of the vertex on which <code>setData()</code> has been applied.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"setData()"},{"content":"<h3 id=\"vertex-reference-storing-data-commitdata\">commitData()</h3><p>Atomically modify properties of the vertex. Unlike setData(), which just overwrites the properties regardless of their previous values, commitData() is used to modify the existing value to a new value, ensuring there are no conflicts with other clients writing to the same location at the same time.</p><p><strong>Usage</strong></p><p><code>vref.commitData(applyFunction [, onComplete])</code></p><ul>\n<li><strong>applyFunction</strong> <code>Function</code> — is used to transform the current value into a new value. It will be passed the current data as a JSON object and it is supposed to return the new data as a JSON object. Note: only the properties defined in the new JSON object is commited to the server, others are persisted.</li>\n<li><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>commitData()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Object</code> — <em>Vertex Reference</em> of the vertex on which <code>commitData()</code> has been applied.</li>\n</ul>\n</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>commitData()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Object</code> — <em>Vertex Reference</em> of the vertex on which <code>commitData()</code> has been applied.</li>\n</ul><p><code>applyFunction</code> is called once and the new data is sent to the server for write. If another client writes to the vertex before your new value is successfully written, the <code>applyFunction</code> will be called again with the new current value, and the write will be retried.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"commitData()"},{"content":"<h3 id=\"vertex-reference-storing-data-removedata\">removeData()</h3><p>Removes one or more data properties from this vertex reference.</p><p><strong>Usage</strong></p><p><code>vref.removeData(propertyName [, onComplete])</code></p><ul>\n<li><strong>propertyName</strong> <code>String</code> / <code>Array</code> — One or more property names to be deleted.</li>\n<li><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>removeData()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Vertex Reference</code> —  of the vertex on which <code>removeData()</code> has been applied.</li>\n</ul>\n</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>removeData()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Vertex Reference</code> —  of the vertex on which <code>removeData()</code> has been applied.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"removeData()"},{"content":"<h3 id=\"vertex-reference-storing-data-setedge\">setEdge()</h3><p>Create a link to another vertex. You can optionally set priority to links.</p><p><strong>Usage</strong></p><p><code>vref.setEdge(edgeName [, outVertex, priority, onComplete])</code></p><ul>\n<li><strong>edgeName</strong> <code>String</code> — Identifier for the outVertex. The identifier can contain all ascii characters except  whitespaces, ‘:’, ‘/’ and ‘~’. You can use <code>Appbase.uuid()</code> for setting a unique identifier.</li>\n<li><strong>outVertex</strong> <code>Vertex Reference</code> (optional) — If passed, <code>setEdge()</code> will create a link from <code>vref</code> to the <code>outVertex</code>. Otherwise, it will create a new vertex and create a link from <code>vref</code> to it.</li>\n<li><strong>priority</strong> <code>Number</code> (optional) — If passed, the link will be assigned the priority. By default, the timestamp of edge creation is used as it’s priority.</li>\n<li><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed three arguments:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>setEdge()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Vertex Reference</code> — of the vertex on which <code>setEdge()</code> has been applied.</li>\n<li><strong>outVertexRef</strong> <code>Vertex Reference</code> - of the vertex which is added as an edge.</li>\n</ul>\n</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed three arguments:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>setEdge()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Vertex Reference</code> — of the vertex on which <code>setEdge()</code> has been applied.</li>\n<li><strong>outVertexRef</strong> <code>Vertex Reference</code> - of the vertex which is added as an edge.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"setEdge()"},{"content":"<h3 id=\"vertex-reference-storing-data-removeedge\">removeEdge()</h3><p>Remove a link from the current vertex.</p><p><strong>Usage</strong></p><p><code>vref.removeEdge(edgeName [, onComplete])</code></p><ul>\n<li><strong>edgeName</strong> <code>String</code> / <code>Array</code> — One or more edge names to be deleted.</li>\n<li><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>removeEdge()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Vertex Reference</code> —  of the vertex on which <code>removeEdge()</code> has been applied.</li>\n</ul>\n</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed two arguments:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>removeEdge()</code> worked successfully.</li>\n<li><strong>vref</strong> <code>Vertex Reference</code> —  of the vertex on which <code>removeEdge()</code> has been applied.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"removeEdge()"},{"content":"<h3 id=\"vertex-reference-storing-data-destroy\">destroy()</h3><p>Destroys a vertex from Appbase. All edges pointing to this vertex are also removed. This causes <strong>vertex_removed</strong> to be fired on the namespace where this vertex belongs.</p><p><strong>Usage</strong></p><p><code>vref.destroy([, onComplete])</code></p><ul>\n<li><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed the argument:</p>\n<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>removeEdge()</code> worked successfully.</li>\n</ul>\n</li>\n</ul><p><strong>onComplete</strong> <code>Function</code> (optional) — will be passed the argument:</p><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if <code>removeEdge()</code> worked successfully.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"destroy()"},{"content":"<h2 id=\"vertex-reference-retrieving-data\">Retrieving Data</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"RETRIEVING DATA"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onproperties\">on(‘properties’)</h3><p>Fetch current properties, and listen to changes in the properties of a vertex.</p><p><strong>Usage</strong></p><p><code>vref.on('properties', callback)</code></p><ul>\n<li><strong>callback</strong> <code>Function</code> —- will be passed these as arguments:<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if :function-name:<code>on('properties')</code> listening is successful</li>\n<li><strong>abref</strong> <code>Appbase Vertex Reference</code> — points to the path on which the event is fired</li>\n<li><strong>snapObj</strong> <code>Property Snapshot</code> — Snapshot of the data stored in the vertex. Take a look at the documentation of <code>Property Snapshot</code> on this page</li>\n</ul>\n</li>\n</ul><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> — <em>String</em> containing the error message, <em>null</em> if :function-name:<code>on('properties')</code> listening is successful</li>\n<li><strong>abref</strong> <code>Appbase Vertex Reference</code> — points to the path on which the event is fired</li>\n<li><strong>snapObj</strong> <code>Property Snapshot</code> — Snapshot of the data stored in the vertex. Take a look at the documentation of <code>Property Snapshot</code> on this page</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"on(‘properties’)"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onceproperties\">once(‘properties’)</h3><p>As the name suggests, it works exactly like <code>on(\"properties\")</code> except that it will be fired only once. When you want to fetch only the current properties and don’t want to listen to changes, you can use <code>once()</code>.</p><p><strong>Usage</strong></p><p><code>vref.once('properties', callback)</code></p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"once(‘properties’)"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onedge_added\">on(‘edge_added’)</h3><p>Get existing edges added at a location, and listen to new ones.</p><p><strong>Usage</strong></p><p><code>vref.on('edge_added' [, filters ],  callback [, onComplete])</code></p><ul>\n<li><strong>filters</strong> <code>JSON Object</code> - Allows filtering of edges, and supports <code>startAt</code>, <code>endAt</code>, <code>limit</code>, <code>skip</code> and <code>onlyNew</code> filters</li>\n<li><strong>callback</strong> <code>Function</code> - will be passed these as arguments:<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code></li>\n<li><strong>edgeRef</strong> <code>Appbase Vertex Reference</code> - pointing to path of the edge</li>\n<li><strong>snapObj</strong> <code>Edge Snapshot</code> - Snapshot of the edge. Take a look at the documentation of <code>Edge Snapshot</code> on this page</li>\n</ul>\n</li>\n<li><strong>onComplete</strong> <code>Function</code> - Called when all the existing edges have been retrieved. It will be called only once, with argments:<ul>\n<li><strong>vref</strong> <code>Vertex reference</code> - of the vertex where edges are being added</li>\n</ul>\n</li>\n</ul><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code></li>\n<li><strong>edgeRef</strong> <code>Appbase Vertex Reference</code> - pointing to path of the edge</li>\n<li><strong>snapObj</strong> <code>Edge Snapshot</code> - Snapshot of the edge. Take a look at the documentation of <code>Edge Snapshot</code> on this page</li>\n</ul><ul>\n<li><strong>vref</strong> <code>Vertex reference</code> - of the vertex where edges are being added</li>\n</ul><p>With edge filters, it is possible to fetch only certain edges. It comes handy when there are large number of edges and you want to paginate them.</p><p>When more than one filter is provided, they work as logical <code>AND</code> and only the edges matchihg all filters will be fetched. This is what each filter means:</p><p>Notice that:</p><ul>\n<li>Filters are a way to fetch existing edges, thus they work only with _edge<em>added</em> event</li>\n<li>Edges are always returned ordered according to their priorities</li>\n<li>When <em>endAt</em> &lt; <em>startAt</em>, edges are returned in reverse order</li>\n<li>You can NOT apply all the numeric filters (first four) to newly created edges, they are only for existing edges and it is NOT possible to apply filters to newly created edges in realtime<ul>\n<li>This means that the numeric filters can not be used with <em>onlyNew</em> set to be <code>true</code></li>\n<li><em>Newly created</em> edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</li>\n</ul>\n</li>\n</ul><ul>\n<li>This means that the numeric filters can not be used with <em>onlyNew</em> set to be <code>true</code></li>\n<li><em>Newly created</em> edges will NOT be fired when any of the numeric filter is applied, i.e. only the existing edges will be returned</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"on(‘edge_added’)"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onedge_removed\">on(‘edge_removed’)</h3><p>Listen to removal of edges. </p><p><strong>Usage</strong></p><p><code>vref.on('edge_removed', callback)</code></p><ul>\n<li><strong>callback</strong> <code>Function</code> - will be passed these as arguments:<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> —</li>\n<li><strong>edgeRef</strong> <code>Appbase Vertex Reference</code> - pointing to path of the edge.</li>\n<li><strong>snapObj</strong> <code>Edge Snapshot</code> - Snapshot of the edge. Take a look at the documentation of <code>Edge Snapshot</code> on this page</li>\n</ul>\n</li>\n</ul><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> —</li>\n<li><strong>edgeRef</strong> <code>Appbase Vertex Reference</code> - pointing to path of the edge.</li>\n<li><strong>snapObj</strong> <code>Edge Snapshot</code> - Snapshot of the edge. Take a look at the documentation of <code>Edge Snapshot</code> on this page</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"on(‘edge_removed’)"},{"content":"<h3 id=\"vertex-reference-retrieving-data-onedge_changed\">on(‘edge_changed’)</h3><p>When ever an edge is replaced, i.e. <code>setEdge()</code> is called with an existing edge name, this event is fired.</p><p><strong>Usage</strong></p><p><code>vref.on('edge_changed', callback)</code></p><ul>\n<li><strong>callback</strong> <code>Function</code> - will be passed these as arguments:<ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> —</li>\n<li><strong>edgeRef</strong> <code>Appbase Vertex Reference</code> - pointing to path of the edge.</li>\n<li><strong>snapObj</strong> <code>Edge Snapshot</code> - Snapshot of the edge. Take a look at the documentation of <code>Edge Snapshot</code> on this page</li>\n</ul>\n</li>\n</ul><ul>\n<li><strong>error</strong> <code>String</code> / <code>null</code> —</li>\n<li><strong>edgeRef</strong> <code>Appbase Vertex Reference</code> - pointing to path of the edge.</li>\n<li><strong>snapObj</strong> <code>Edge Snapshot</code> - Snapshot of the edge. Take a look at the documentation of <code>Edge Snapshot</code> on this page</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"on(‘edge_changed’)"},{"content":"<h2 id=\"vertex-reference-utility\">Utility</h2>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"UTILITY"},{"content":"<h3 id=\"vertex-reference-utility-outvertex\">outVertex()</h3><p>Reference to the corresponding <code>outVertex</code> with the given name.</p><p><strong>Usage</strong></p><p><code>vref.outVertex(edgeName)</code></p><ul>\n<li><strong>edgeName</strong> <code>String</code> — outVertex identifier.</li>\n</ul><p><strong>Returns</strong></p><ul>\n<li><strong>vref</strong> <code>Vertex Reference</code> of the outVertex.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"outVertex()"},{"content":"<h3 id=\"vertex-reference-utility-invertex\">inVertex()</h3><p>Reference to the corresponding <code>inVertex</code> from the current vertex.</p><p><strong>Usage</strong></p><p><code>vref.inVertex()</code></p><p><code>Note:</code> Since vertices are accessed via a path, there is only one <code>inVertex</code> for each vertex. Calling this method on the root vertex such as ``Appbase.ns(“Domains”).v(“www.appbase.io”) will thrown an error.</p><p><strong>Returns</strong></p><ul>\n<li><strong>vref</strong> <code>Vertex Reference</code> of the inVertex.</li>\n</ul>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"inVertex()"},{"content":"<h3 id=\"vertex-reference-utility-path\">path()</h3><p>Returns the path of the current reference.</p><p><strong>Usage</strong></p><p><code>vref.path()</code></p><p>The method accepts no arguments, and returns a path of the <code>vref</code> resource.</p><p><strong>Returns</strong></p><p><strong>path</strong> <code>String</code> Path of the <code>vref</code> is a UNIX style path of the format namespace/:vertex1/:vertex2/vref.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"path()"},{"content":"<h3 id=\"vertex-reference-utility-name\">name()</h3><p>Returns the name of the current reference.</p><p><strong>Usage</strong></p><p><code>vref.name()</code></p><p><strong>Returns</strong></p><p><strong>name</strong> <code>String</code> Name of the <code>vref</code>.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"name()"},{"content":"<h3 id=\"vertex-reference-utility-url\">URL()</h3><p>Appbase URL of the current reference.</p><p><strong>Usage</strong></p><p><code>vref.URL()</code></p><p>The method accepts no arguments, and returns a URL of the <code>vref</code> resource.</p><p><strong>Returns</strong></p><p><strong>url</strong> <code>String</code> Data URL of the namespace reference. The format of the URL is <code>api.appbase.io/:appname/:version/ns/:vertex1/:vertex2</code>.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"URL()"},{"content":"<h1 id=\"data-snapshots\">Data Snapshots</h1><p>Data snapshots are immutable copies of the data stored at <code>Appbase References</code><em>. There are two kinds of snapshots: <code>Property Snapshot</code></em> and <code>Edge Snapshot</code>_, fired when listening to on(‘properties’) or one of the edge listeners.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"DATA SNAPSHOTS"},{"content":"<h3 id=\"data-snapshots-property-snapshot\">Property Snapshot</h3><p>It holds the property data of a vertex in Appbase. It has the following methods to obtain the changes in the Appbase Reference.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"Property Snapshot"},{"content":"<h3 id=\"data-snapshots-edge-snapshot\">Edge Snapshot</h3><p>It holds the edge data. It has the following methods to obtain the edge related changes in the Appbase Reference.</p>","link":"./v2.0/javascript/api-reference.html","spaLink":"#/v2.0/javascript/api-reference","title":"Edge Snapshot"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v2.0/javascript/quick-start.html","spaLink":"#/v2.0/javascript/quick-start","title":"Docbase"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v2.0/javascript/oauth.html","spaLink":"#/v2.0/javascript/oauth","title":"Docbase"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v2.0/rest/api-reference.html","spaLink":"#/v2.0/rest/api-reference","title":"Docbase"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v2.0/search/quick-start.html","spaLink":"#/v2.0/search/quick-start","title":"Docbase"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v2.0/search/use-cases.html","spaLink":"#/v2.0/search/use-cases","title":"Docbase"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v3.0/changelog/changelog.html","spaLink":"#/v3.0/changelog/changelog","title":"Docbase"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v3.0/concepts/datamodel.html","spaLink":"#/v3.0/concepts/datamodel","title":"Docbase"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v3.0/javascript/api-reference.html","spaLink":"#/v3.0/javascript/api-reference","title":"Docbase"},{"content":"<h1>Doc<b>base</b></h1>","link":"./v3.0/rest/api-reference.html","spaLink":"#/v3.0/rest/api-reference","title":"Docbase"}]